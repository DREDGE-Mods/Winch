<?xml version="1.0"?>
<doc>
    <assembly>
        <name>MonoMod.Backports</name>
    </assembly>
    <members>
        <member name="T:System.Diagnostics.CodeAnalysis.DynamicallyAccessedMembersAttribute">
             <summary>
             Indicates that certain members on a specified <see cref="T:System.Type"/> are accessed dynamically,
             for example through <see cref="N:System.Reflection"/>.
             </summary>
             <remarks>
             This allows tools to understand which members are being accessed during the execution
             of a program.
            
             This attribute is valid on members whose type is <see cref="T:System.Type"/> or <see cref="T:System.String"/>.
            
             When this attribute is applied to a location of type <see cref="T:System.String"/>, the assumption is
             that the string represents a fully qualified type name.
            
             When this attribute is applied to a class, interface, or struct, the members specified
             can be accessed dynamically on <see cref="T:System.Type"/> instances returned from calling
             <see cref="M:System.Object.GetType"/> on instances of that class, interface, or struct.
            
             If the attribute is applied to a method it's treated as a special case and it implies
             the attribute should be applied to the "this" parameter of the method. As such the attribute
             should only be used on instance methods of types assignable to System.Type (or string, but no methods
             will use it there).
             </remarks>
        </member>
        <member name="M:System.Diagnostics.CodeAnalysis.DynamicallyAccessedMembersAttribute.#ctor(System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes)">
            <summary>
            Initializes a new instance of the <see cref="T:System.Diagnostics.CodeAnalysis.DynamicallyAccessedMembersAttribute"/> class
            with the specified member types.
            </summary>
            <param name="memberTypes">The types of members dynamically accessed.</param>
        </member>
        <member name="P:System.Diagnostics.CodeAnalysis.DynamicallyAccessedMembersAttribute.MemberTypes">
            <summary>
            Gets the <see cref="T:System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes"/> which specifies the type
            of members dynamically accessed.
            </summary>
        </member>
        <member name="T:System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes">
             <summary>
             Specifies the types of members that are dynamically accessed.
            
             This enumeration has a <see cref="T:System.FlagsAttribute"/> attribute that allows a
             bitwise combination of its member values.
             </summary>
        </member>
        <member name="F:System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.None">
            <summary>
            Specifies no members.
            </summary>
        </member>
        <member name="F:System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.PublicParameterlessConstructor">
            <summary>
            Specifies the default, parameterless public constructor.
            </summary>
        </member>
        <member name="F:System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.PublicConstructors">
            <summary>
            Specifies all public constructors.
            </summary>
        </member>
        <member name="F:System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.NonPublicConstructors">
            <summary>
            Specifies all non-public constructors.
            </summary>
        </member>
        <member name="F:System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.PublicMethods">
            <summary>
            Specifies all public methods.
            </summary>
        </member>
        <member name="F:System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.NonPublicMethods">
            <summary>
            Specifies all non-public methods.
            </summary>
        </member>
        <member name="F:System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.PublicFields">
            <summary>
            Specifies all public fields.
            </summary>
        </member>
        <member name="F:System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.NonPublicFields">
            <summary>
            Specifies all non-public fields.
            </summary>
        </member>
        <member name="F:System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.PublicNestedTypes">
            <summary>
            Specifies all public nested types.
            </summary>
        </member>
        <member name="F:System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.NonPublicNestedTypes">
            <summary>
            Specifies all non-public nested types.
            </summary>
        </member>
        <member name="F:System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.PublicProperties">
            <summary>
            Specifies all public properties.
            </summary>
        </member>
        <member name="F:System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.NonPublicProperties">
            <summary>
            Specifies all non-public properties.
            </summary>
        </member>
        <member name="F:System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.PublicEvents">
            <summary>
            Specifies all public events.
            </summary>
        </member>
        <member name="F:System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.NonPublicEvents">
            <summary>
            Specifies all non-public events.
            </summary>
        </member>
        <member name="F:System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.All">
            <summary>
            Specifies all members.
            </summary>
        </member>
        <member name="T:System.Diagnostics.CodeAnalysis.UnscopedRefAttribute">
            <summary>
            Used to indicate a byref escapes and is not scoped.
            </summary>
            <remarks>
            <para>
            There are several cases where the C# compiler treats a <see langword="ref"/> as implicitly
            <see langword="scoped"/> - where the compiler does not allow the <see langword="ref"/> to escape the method.
            </para>
            <para>
            For example:
            <list type="number">
                <item><see langword="this"/> for <see langword="struct"/> instance methods.</item>
                <item><see langword="ref"/> parameters that refer to <see langword="ref"/> <see langword="struct"/> types.</item>
                <item><see langword="out"/> parameters.</item>
            </list>
            </para>
            <para>
            This attribute is used in those instances where the <see langword="ref"/> should be allowed to escape.
            </para>
            <para>
            Applying this attribute, in any form, has impact on consumers of the applicable API. It is necessary for
            API authors to understand the lifetime implications of applying this attribute and how it may impact their users.
            </para>
            </remarks>
        </member>
        <member name="M:System.Diagnostics.CodeAnalysis.UnscopedRefAttribute.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:System.Diagnostics.CodeAnalysis.UnscopedRefAttribute"/> class.
            </summary>
        </member>
        <member name="T:System.Runtime.CompilerServices.IsExternalInit">
            <summary>
                Reserved to be used by the compiler for tracking metadata.
                This class should not be used by developers in source code.
            </summary>
            <remarks>
                This definition is provided by the <i>IsExternalInit</i> NuGet package (https://www.nuget.org/packages/IsExternalInit).
                Please see https://github.com/manuelroemer/IsExternalInit for more information.
            </remarks>
        </member>
        <member name="T:System.Runtime.CompilerServices.DefaultInterpolatedStringHandler">
            <summary>Provides a handler used by the language compiler to process interpolated strings into <see cref="T:System.String"/> instances.</summary>
        </member>
        <member name="F:System.Runtime.CompilerServices.DefaultInterpolatedStringHandler.GuessedLengthPerHole">
            <summary>Expected average length of formatted data used for an individual interpolation expression result.</summary>
            <remarks>
            This is inherited from string.Format, and could be changed based on further data.
            string.Format actually uses `format.Length + args.Length * 8`, but format.Length
            includes the format items themselves, e.g. "{0}", and since it's rare to have double-digit
            numbers of items, we bump the 8 up to 11 to account for the three extra characters in "{d}",
            since the compiler-provided base length won't include the equivalent character count.
            </remarks>
        </member>
        <member name="F:System.Runtime.CompilerServices.DefaultInterpolatedStringHandler.MinimumArrayPoolLength">
            <summary>Minimum size array to rent from the pool.</summary>
            <remarks>Same as stack-allocation size used today by string.Format.</remarks>
        </member>
        <member name="F:System.Runtime.CompilerServices.DefaultInterpolatedStringHandler._provider">
            <summary>Optional provider to pass to IFormattable.ToString or ISpanFormattable.TryFormat calls.</summary>
        </member>
        <member name="F:System.Runtime.CompilerServices.DefaultInterpolatedStringHandler._arrayToReturnToPool">
            <summary>Array rented from the array pool and used to back <see cref="F:System.Runtime.CompilerServices.DefaultInterpolatedStringHandler._chars"/>.</summary>
        </member>
        <member name="F:System.Runtime.CompilerServices.DefaultInterpolatedStringHandler._chars">
            <summary>The span to write into.</summary>
        </member>
        <member name="F:System.Runtime.CompilerServices.DefaultInterpolatedStringHandler._pos">
            <summary>Position at which to write the next character.</summary>
        </member>
        <member name="F:System.Runtime.CompilerServices.DefaultInterpolatedStringHandler._hasCustomFormatter">
            <summary>Whether <see cref="F:System.Runtime.CompilerServices.DefaultInterpolatedStringHandler._provider"/> provides an ICustomFormatter.</summary>
            <remarks>
            Custom formatters are very rare.  We want to support them, but it's ok if we make them more expensive
            in order to make them as pay-for-play as possible.  So, we avoid adding another reference type field
            to reduce the size of the handler and to reduce required zero'ing, by only storing whether the provider
            provides a formatter, rather than actually storing the formatter.  This in turn means, if there is a
            formatter, we pay for the extra interface call on each AppendFormatted that needs it.
            </remarks>
        </member>
        <member name="M:System.Runtime.CompilerServices.DefaultInterpolatedStringHandler.#ctor(System.Int32,System.Int32)">
            <summary>Creates a handler used to translate an interpolated string into a <see cref="T:System.String"/>.</summary>
            <param name="literalLength">The number of constant characters outside of interpolation expressions in the interpolated string.</param>
            <param name="formattedCount">The number of interpolation expressions in the interpolated string.</param>
            <remarks>This is intended to be called only by compiler-generated code. Arguments are not validated as they'd otherwise be for members intended to be used directly.</remarks>
        </member>
        <member name="M:System.Runtime.CompilerServices.DefaultInterpolatedStringHandler.#ctor(System.Int32,System.Int32,System.IFormatProvider)">
            <summary>Creates a handler used to translate an interpolated string into a <see cref="T:System.String"/>.</summary>
            <param name="literalLength">The number of constant characters outside of interpolation expressions in the interpolated string.</param>
            <param name="formattedCount">The number of interpolation expressions in the interpolated string.</param>
            <param name="provider">An object that supplies culture-specific formatting information.</param>
            <remarks>This is intended to be called only by compiler-generated code. Arguments are not validated as they'd otherwise be for members intended to be used directly.</remarks>
        </member>
        <member name="M:System.Runtime.CompilerServices.DefaultInterpolatedStringHandler.#ctor(System.Int32,System.Int32,System.IFormatProvider,System.Span{System.Char})">
            <summary>Creates a handler used to translate an interpolated string into a <see cref="T:System.String"/>.</summary>
            <param name="literalLength">The number of constant characters outside of interpolation expressions in the interpolated string.</param>
            <param name="formattedCount">The number of interpolation expressions in the interpolated string.</param>
            <param name="provider">An object that supplies culture-specific formatting information.</param>
            <param name="initialBuffer">A buffer temporarily transferred to the handler for use as part of its formatting.  Contents may be overwritten.</param>
            <remarks>This is intended to be called only by compiler-generated code. Arguments are not validated as they'd otherwise be for members intended to be used directly.</remarks>
        </member>
        <member name="M:System.Runtime.CompilerServices.DefaultInterpolatedStringHandler.GetDefaultLength(System.Int32,System.Int32)">
            <summary>Derives a default length with which to seed the handler.</summary>
            <param name="literalLength">The number of constant characters outside of interpolation expressions in the interpolated string.</param>
            <param name="formattedCount">The number of interpolation expressions in the interpolated string.</param>
        </member>
        <member name="M:System.Runtime.CompilerServices.DefaultInterpolatedStringHandler.ToString">
            <summary>Gets the built <see cref="T:System.String"/>.</summary>
            <returns>The built string.</returns>
        </member>
        <member name="M:System.Runtime.CompilerServices.DefaultInterpolatedStringHandler.ToStringAndClear">
            <summary>Gets the built <see cref="T:System.String"/> and clears the handler.</summary>
            <returns>The built string.</returns>
            <remarks>
            This releases any resources used by the handler. The method should be invoked only
            once and as the last thing performed on the handler. Subsequent use is erroneous, ill-defined,
            and may destabilize the process, as may using any other copies of the handler after ToStringAndClear
            is called on any one of them.
            </remarks>
        </member>
        <member name="M:System.Runtime.CompilerServices.DefaultInterpolatedStringHandler.Clear">
            <summary>Clears the handler, returning any rented array to the pool.</summary>
        </member>
        <member name="P:System.Runtime.CompilerServices.DefaultInterpolatedStringHandler.Text">
            <summary>Gets a span of the written characters thus far.</summary>
        </member>
        <member name="M:System.Runtime.CompilerServices.DefaultInterpolatedStringHandler.AppendLiteral(System.String)">
            <summary>Writes the specified string to the handler.</summary>
            <param name="value">The string to write.</param>
        </member>
        <member name="M:System.Runtime.CompilerServices.DefaultInterpolatedStringHandler.AppendStringDirect(System.String)">
            <summary>Writes the specified string to the handler.</summary>
            <param name="value">The string to write.</param>
        </member>
        <member name="M:System.Runtime.CompilerServices.DefaultInterpolatedStringHandler.AppendFormatted``1(``0)">
            <summary>Writes the specified value to the handler.</summary>
            <param name="value">The value to write.</param>
            <typeparam name="T">The type of the value to write.</typeparam>
        </member>
        <member name="M:System.Runtime.CompilerServices.DefaultInterpolatedStringHandler.AppendFormatted``1(``0,System.String)">
            <summary>Writes the specified value to the handler.</summary>
            <param name="value">The value to write.</param>
            <param name="format">The format string.</param>
            <typeparam name="T">The type of the value to write.</typeparam>
        </member>
        <member name="M:System.Runtime.CompilerServices.DefaultInterpolatedStringHandler.AppendFormatted``1(``0,System.Int32)">
            <summary>Writes the specified value to the handler.</summary>
            <param name="value">The value to write.</param>
            <param name="alignment">Minimum number of characters that should be written for this value.  If the value is negative, it indicates left-aligned and the required minimum is the absolute value.</param>
            <typeparam name="T">The type of the value to write.</typeparam>
        </member>
        <member name="M:System.Runtime.CompilerServices.DefaultInterpolatedStringHandler.AppendFormatted``1(``0,System.Int32,System.String)">
            <summary>Writes the specified value to the handler.</summary>
            <param name="value">The value to write.</param>
            <param name="format">The format string.</param>
            <param name="alignment">Minimum number of characters that should be written for this value.  If the value is negative, it indicates left-aligned and the required minimum is the absolute value.</param>
            <typeparam name="T">The type of the value to write.</typeparam>
        </member>
        <member name="M:System.Runtime.CompilerServices.DefaultInterpolatedStringHandler.AppendFormatted(System.ReadOnlySpan{System.Char})">
            <summary>Writes the specified character span to the handler.</summary>
            <param name="value">The span to write.</param>
        </member>
        <member name="M:System.Runtime.CompilerServices.DefaultInterpolatedStringHandler.AppendFormatted(System.ReadOnlySpan{System.Char},System.Int32,System.String)">
            <summary>Writes the specified string of chars to the handler.</summary>
            <param name="value">The span to write.</param>
            <param name="alignment">Minimum number of characters that should be written for this value.  If the value is negative, it indicates left-aligned and the required minimum is the absolute value.</param>
            <param name="format">The format string.</param>
        </member>
        <member name="M:System.Runtime.CompilerServices.DefaultInterpolatedStringHandler.AppendFormatted(System.String)">
            <summary>Writes the specified value to the handler.</summary>
            <param name="value">The value to write.</param>
        </member>
        <member name="M:System.Runtime.CompilerServices.DefaultInterpolatedStringHandler.AppendFormattedSlow(System.String)">
            <summary>Writes the specified value to the handler.</summary>
            <param name="value">The value to write.</param>
            <remarks>
            Slow path to handle a custom formatter, potentially null value,
            or a string that doesn't fit in the current buffer.
            </remarks>
        </member>
        <member name="M:System.Runtime.CompilerServices.DefaultInterpolatedStringHandler.AppendFormatted(System.String,System.Int32,System.String)">
            <summary>Writes the specified value to the handler.</summary>
            <param name="value">The value to write.</param>
            <param name="alignment">Minimum number of characters that should be written for this value.  If the value is negative, it indicates left-aligned and the required minimum is the absolute value.</param>
            <param name="format">The format string.</param>
        </member>
        <member name="M:System.Runtime.CompilerServices.DefaultInterpolatedStringHandler.AppendFormatted(System.Object,System.Int32,System.String)">
            <summary>Writes the specified value to the handler.</summary>
            <param name="value">The value to write.</param>
            <param name="alignment">Minimum number of characters that should be written for this value.  If the value is negative, it indicates left-aligned and the required minimum is the absolute value.</param>
            <param name="format">The format string.</param>
        </member>
        <member name="M:System.Runtime.CompilerServices.DefaultInterpolatedStringHandler.HasCustomFormatter(System.IFormatProvider)">
            <summary>Gets whether the provider provides a custom formatter.</summary>
        </member>
        <member name="M:System.Runtime.CompilerServices.DefaultInterpolatedStringHandler.AppendCustomFormatter``1(``0,System.String)">
            <summary>Formats the value using the custom formatter from the provider.</summary>
            <param name="value">The value to write.</param>
            <param name="format">The format string.</param>
            <typeparam name="T">The type of the value to write.</typeparam>
        </member>
        <member name="M:System.Runtime.CompilerServices.DefaultInterpolatedStringHandler.AppendOrInsertAlignmentIfNeeded(System.Int32,System.Int32)">
            <summary>Handles adding any padding required for aligning a formatted value in an interpolation expression.</summary>
            <param name="startingPos">The position at which the written value started.</param>
            <param name="alignment">Non-zero minimum number of characters that should be written for this value.  If the value is negative, it indicates left-aligned and the required minimum is the absolute value.</param>
        </member>
        <member name="M:System.Runtime.CompilerServices.DefaultInterpolatedStringHandler.EnsureCapacityForAdditionalChars(System.Int32)">
            <summary>Ensures <see cref="F:System.Runtime.CompilerServices.DefaultInterpolatedStringHandler._chars"/> has the capacity to store <paramref name="additionalChars"/> beyond <see cref="F:System.Runtime.CompilerServices.DefaultInterpolatedStringHandler._pos"/>.</summary>
        </member>
        <member name="M:System.Runtime.CompilerServices.DefaultInterpolatedStringHandler.GrowThenCopyString(System.String)">
            <summary>Fallback for fast path in <see cref="M:System.Runtime.CompilerServices.DefaultInterpolatedStringHandler.AppendStringDirect(System.String)"/> when there's not enough space in the destination.</summary>
            <param name="value">The string to write.</param>
        </member>
        <member name="M:System.Runtime.CompilerServices.DefaultInterpolatedStringHandler.GrowThenCopySpan(System.ReadOnlySpan{System.Char})">
            <summary>Fallback for <see cref="M:System.Runtime.CompilerServices.DefaultInterpolatedStringHandler.AppendFormatted(System.ReadOnlySpan{System.Char})"/> for when not enough space exists in the current buffer.</summary>
            <param name="value">The span to write.</param>
        </member>
        <member name="M:System.Runtime.CompilerServices.DefaultInterpolatedStringHandler.Grow(System.Int32)">
            <summary>Grows <see cref="F:System.Runtime.CompilerServices.DefaultInterpolatedStringHandler._chars"/> to have the capacity to store at least <paramref name="additionalChars"/> beyond <see cref="F:System.Runtime.CompilerServices.DefaultInterpolatedStringHandler._pos"/>.</summary>
        </member>
        <member name="M:System.Runtime.CompilerServices.DefaultInterpolatedStringHandler.Grow">
            <summary>Grows the size of <see cref="F:System.Runtime.CompilerServices.DefaultInterpolatedStringHandler._chars"/>.</summary>
        </member>
        <member name="M:System.Runtime.CompilerServices.DefaultInterpolatedStringHandler.GrowCore(System.UInt32)">
            <summary>Grow the size of <see cref="F:System.Runtime.CompilerServices.DefaultInterpolatedStringHandler._chars"/> to at least the specified <paramref name="requiredMinCapacity"/>.</summary>
        </member>
        <member name="T:System.Runtime.CompilerServices.DisableRuntimeMarshallingAttribute">
             <summary>
             Disables the built-in runtime managed/unmanaged marshalling subsystem for
             P/Invokes, Delegate types, and unmanaged function pointer invocations.
             </summary>
             <remarks>
             <para>Note: This does nothing on runtimes older than .NET 7. It is provided entirely for forward compatibility.</para>
             The built-in marshalling subsystem has some behaviors that cannot be changed due to
             backward-compatibility requirements. This attribute allows disabling the built-in
             subsystem and instead uses the following rules for P/Invokes, Delegates,
             and unmanaged function pointer invocations:
            
             - All value types that do not contain reference type fields recursively (<c>unmanaged</c> in C#) are blittable
             - Value types that recursively have any fields that have <c>[StructLayout(LayoutKind.Auto)]</c> are disallowed from interop.
             - All reference types are disallowed from usage in interop scenarios.
             - SetLastError support in P/Invokes is disabled.
             - varargs support is disabled.
             - LCIDConversionAttribute support is disabled.
             </remarks>
        </member>
        <member name="T:System.Runtime.CompilerServices.InterpolatedStringHandlerAttribute">
            <summary>Indicates the attributed type is to be used as an interpolated string handler.</summary>
        </member>
        <member name="M:System.Runtime.CompilerServices.InterpolatedStringHandlerAttribute.#ctor">
            <summary>Initializes the <see cref="T:System.Runtime.CompilerServices.InterpolatedStringHandlerAttribute"/>.</summary>
        </member>
        <member name="T:System.Runtime.CompilerServices.InterpolatedStringHandlerArgumentAttribute">
            <summary>Indicates which arguments to a method involving an interpolated string handler should be passed to that handler.</summary>
        </member>
        <member name="M:System.Runtime.CompilerServices.InterpolatedStringHandlerArgumentAttribute.#ctor(System.String)">
            <summary>Initializes a new instance of the <see cref="T:System.Runtime.CompilerServices.InterpolatedStringHandlerArgumentAttribute"/> class.</summary>
            <param name="argument">The name of the argument that should be passed to the handler.</param>
            <remarks><see langword="null"/> may be used as the name of the receiver in an instance method.</remarks>
        </member>
        <member name="M:System.Runtime.CompilerServices.InterpolatedStringHandlerArgumentAttribute.#ctor(System.String[])">
            <summary>Initializes a new instance of the <see cref="T:System.Runtime.CompilerServices.InterpolatedStringHandlerArgumentAttribute"/> class.</summary>
            <param name="arguments">The names of the arguments that should be passed to the handler.</param>
            <remarks><see langword="null"/> may be used as the name of the receiver in an instance method.</remarks>
        </member>
        <member name="P:System.Runtime.CompilerServices.InterpolatedStringHandlerArgumentAttribute.Arguments">
            <summary>Gets the names of the arguments that should be passed to the handler.</summary>
            <remarks><see langword="null"/> may be used as the name of the receiver in an instance method.</remarks>
        </member>
        <member name="T:System.Runtime.CompilerServices.ITuple">
            <summary>
            This interface is required for types that want to be indexed into by dynamic patterns.
            </summary>
        </member>
        <member name="P:System.Runtime.CompilerServices.ITuple.Length">
            <summary>
            The number of positions in this data structure.
            </summary>
        </member>
        <member name="P:System.Runtime.CompilerServices.ITuple.Item(System.Int32)">
            <summary>
            Get the element at position <param name="index"/>.
            </summary>
        </member>
        <member name="T:System.Runtime.CompilerServices.ModuleInitializerAttribute">
             <summary>
             Used to indicate to the compiler that a method should be called
             in its containing module's initializer.
             </summary>
             <remarks>
             When one or more valid methods
             with this attribute are found in a compilation, the compiler will
             emit a module initializer which calls each of the attributed methods.
            
             Certain requirements are imposed on any method targeted with this attribute:
             - The method must be `static`.
             - The method must be an ordinary member method, as opposed to a property accessor, constructor, local function, etc.
             - The method must be parameterless.
             - The method must return `void`.
             - The method must not be generic or be contained in a generic type.
             - The method's effective accessibility must be `internal` or `public`.
            
             The specification for module initializers in the .NET runtime can be found here:
             https://github.com/dotnet/runtime/blob/main/docs/design/specs/Ecma-335-Augments.md#module-initializer
             </remarks>
        </member>
        <member name="T:System.Runtime.InteropServices.MemoryMarshal">
            <summary>
            Provides a collection of methods for interoperating with <see cref="T:System.Memory`1"/>, <see cref="T:System.ReadOnlyMemory`1"/>,
            <see cref="T:System.Span`1"/>, and <see cref="T:System.ReadOnlySpan`1"/>.
            </summary>
            <summary>
            Provides a collection of methods for interoperating with <see cref="T:System.Memory`1"/>, <see cref="T:System.ReadOnlyMemory`1"/>,
            <see cref="T:System.Span`1"/>, and <see cref="T:System.ReadOnlySpan`1"/>.
            </summary>
        </member>
        <member name="M:System.Runtime.InteropServices.MemoryMarshal.TryGetArray``1(System.ReadOnlyMemory{``0},System.ArraySegment{``0}@)">
            <summary>
            Get an array segment from the underlying memory.
            If unable to get the array segment, return false with a default array segment.
            </summary>
        </member>
        <member name="M:System.Runtime.InteropServices.MemoryMarshal.TryGetMemoryManager``2(System.ReadOnlyMemory{``0},``1@)">
            <summary>
            Gets an <see cref="T:System.Buffers.MemoryManager`1"/> from the underlying read-only memory.
            If unable to get the <typeparamref name="TManager"/> type, returns false.
            </summary>
            <typeparam name="T">The element type of the <paramref name="memory" />.</typeparam>
            <typeparam name="TManager">The type of <see cref="T:System.Buffers.MemoryManager`1"/> to try and retrive.</typeparam>
            <param name="memory">The memory to get the manager for.</param>
            <param name="manager">The returned manager of the <see cref="T:System.ReadOnlyMemory`1"/>.</param>
            <returns>A <see cref="T:System.Boolean"/> indicating if it was successful.</returns>
        </member>
        <member name="M:System.Runtime.InteropServices.MemoryMarshal.TryGetMemoryManager``2(System.ReadOnlyMemory{``0},``1@,System.Int32@,System.Int32@)">
            <summary>
            Gets an <see cref="T:System.Buffers.MemoryManager`1"/> and <paramref name="start" />, <paramref name="length" /> from the underlying read-only memory.
            If unable to get the <typeparamref name="TManager"/> type, returns false.
            </summary>
            <typeparam name="T">The element type of the <paramref name="memory" />.</typeparam>
            <typeparam name="TManager">The type of <see cref="T:System.Buffers.MemoryManager`1"/> to try and retrive.</typeparam>
            <param name="memory">The memory to get the manager for.</param>
            <param name="manager">The returned manager of the <see cref="T:System.ReadOnlyMemory`1"/>.</param>
            <param name="start">The offset from the start of the <paramref name="manager" /> that the <paramref name="memory" /> represents.</param>
            <param name="length">The length of the <paramref name="manager" /> that the <paramref name="memory" /> represents.</param>
            <returns>A <see cref="T:System.Boolean"/> indicating if it was successful.</returns>
        </member>
        <member name="M:System.Runtime.InteropServices.MemoryMarshal.ToEnumerable``1(System.ReadOnlyMemory{``0})">
            <summary>
            Creates an <see cref="T:System.Collections.Generic.IEnumerable`1"/> view of the given <paramref name="memory" /> to allow
            the <paramref name="memory" /> to be used in existing APIs that take an <see cref="T:System.Collections.Generic.IEnumerable`1"/>.
            </summary>
            <typeparam name="T">The element type of the <paramref name="memory" />.</typeparam>
            <param name="memory">The ReadOnlyMemory to view as an <see cref="T:System.Collections.Generic.IEnumerable`1"/></param>
            <returns>An <see cref="T:System.Collections.Generic.IEnumerable`1"/> view of the given <paramref name="memory" /></returns>
        </member>
        <member name="M:System.Runtime.InteropServices.MemoryMarshal.TryGetString(System.ReadOnlyMemory{System.Char},System.String@,System.Int32@,System.Int32@)">
            <summary>Attempts to get the underlying <see cref="T:System.String"/> from a <see cref="T:System.ReadOnlyMemory`1"/>.</summary>
            <param name="memory">The memory that may be wrapping a <see cref="T:System.String"/> object.</param>
            <param name="text">The string.</param>
            <param name="start">The starting location in <paramref name="text"/>.</param>
            <param name="length">The number of items in <paramref name="text"/>.</param>
            <returns></returns>
        </member>
        <member name="M:System.Runtime.InteropServices.MemoryMarshal.Read``1(System.ReadOnlySpan{System.Byte})">
            <summary>
            Reads a structure of type T out of a read-only span of bytes.
            </summary>
        </member>
        <member name="M:System.Runtime.InteropServices.MemoryMarshal.TryRead``1(System.ReadOnlySpan{System.Byte},``0@)">
            <summary>
            Reads a structure of type T out of a span of bytes.
            <returns>If the span is too small to contain the type T, return false.</returns>
            </summary>
        </member>
        <member name="M:System.Runtime.InteropServices.MemoryMarshal.Write``1(System.Span{System.Byte},``0@)">
            <summary>
            Writes a structure of type T into a span of bytes.
            </summary>
        </member>
        <member name="M:System.Runtime.InteropServices.MemoryMarshal.TryWrite``1(System.Span{System.Byte},``0@)">
            <summary>
            Writes a structure of type T into a span of bytes.
            <returns>If the span is too small to contain the type T, return false.</returns>
            </summary>
        </member>
        <member name="M:System.Runtime.InteropServices.MemoryMarshal.CreateFromPinnedArray``1(``0[],System.Int32,System.Int32)">
            <summary>
            Creates a new memory over the portion of the pre-pinned target array beginning
            at 'start' index and ending at 'end' index (exclusive).
            </summary>
            <param name="array">The pre-pinned target array.</param>
            <param name="start">The index at which to begin the memory.</param>
            <param name="length">The number of items in the memory.</param>
            <remarks>This method should only be called on an array that is already pinned and 
            that array should not be unpinned while the returned Memory<typeparamref name="T"/> is still in use.
            Calling this method on an unpinned array could result in memory corruption.</remarks>
            <remarks>Returns default when <paramref name="array"/> is null.</remarks>
            <exception cref="T:System.ArrayTypeMismatchException">Thrown when <paramref name="array"/> is covariant and array's type is not exactly T[].</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">
            Thrown when the specified <paramref name="start"/> or end index is not in the range (&lt;0 or &gt;=Length).
            </exception>
        </member>
        <member name="M:System.Runtime.InteropServices.MemoryMarshal.AsBytes``1(System.Span{``0})">
            <summary>
            Casts a Span of one primitive type <typeparamref name="T"/> to Span of bytes.
            That type may not contain pointers or references. This is checked at runtime in order to preserve type safety.
            </summary>
            <param name="span">The source slice, of type <typeparamref name="T"/>.</param>
            <exception cref="T:System.ArgumentException">
            Thrown when <typeparamref name="T"/> contains pointers.
            </exception>
            <exception cref="T:System.OverflowException">
            Thrown if the Length property of the new Span would exceed Int32.MaxValue.
            </exception>
        </member>
        <member name="M:System.Runtime.InteropServices.MemoryMarshal.AsBytes``1(System.ReadOnlySpan{``0})">
            <summary>
            Casts a ReadOnlySpan of one primitive type <typeparamref name="T"/> to ReadOnlySpan of bytes.
            That type may not contain pointers or references. This is checked at runtime in order to preserve type safety.
            </summary>
            <param name="span">The source slice, of type <typeparamref name="T"/>.</param>
            <exception cref="T:System.ArgumentException">
            Thrown when <typeparamref name="T"/> contains pointers.
            </exception>
            <exception cref="T:System.OverflowException">
            Thrown if the Length property of the new Span would exceed Int32.MaxValue.
            </exception>
        </member>
        <member name="M:System.Runtime.InteropServices.MemoryMarshal.AsMemory``1(System.ReadOnlyMemory{``0})">
            <summary>Creates a <see cref="T:System.Memory`1"/> from a <see cref="T:System.ReadOnlyMemory`1"/>.</summary>
            <param name="memory">The <see cref="T:System.ReadOnlyMemory`1"/>.</param>
            <returns>A <see cref="T:System.Memory`1"/> representing the same memory as the <see cref="T:System.ReadOnlyMemory`1"/>, but writable.</returns>
            <remarks>
            <see cref="M:System.Runtime.InteropServices.MemoryMarshal.AsMemory``1(System.ReadOnlyMemory{``0})"/> must be used with extreme caution.  <see cref="T:System.ReadOnlyMemory`1"/> is used
            to represent immutable data and other memory that is not meant to be written to; <see cref="T:System.Memory`1"/> instances created
            by <see cref="M:System.Runtime.InteropServices.MemoryMarshal.AsMemory``1(System.ReadOnlyMemory{``0})"/> should not be written to.  The method exists to enable variables typed
            as <see cref="T:System.Memory`1"/> but only used for reading to store a <see cref="T:System.ReadOnlyMemory`1"/>.
            </remarks>
        </member>
        <member name="M:System.Runtime.InteropServices.MemoryMarshal.GetReference``1(System.Span{``0})">
            <summary>
            Returns a reference to the 0th element of the Span. If the Span is empty, returns a reference to the location where the 0th element
            would have been stored. Such a reference can be used for pinning but must never be dereferenced.
            </summary>
        </member>
        <member name="M:System.Runtime.InteropServices.MemoryMarshal.GetReference``1(System.ReadOnlySpan{``0})">
            <summary>
            Returns a reference to the 0th element of the ReadOnlySpan. If the Span is empty, returns a reference to the location where the 0th element
            would have been stored. Such a reference can be used for pinning but must never be dereferenced.
            </summary>
        </member>
        <member name="M:System.Runtime.InteropServices.MemoryMarshal.Cast``2(System.Span{``0})">
            <summary>
            Casts a Span of one primitive type <typeparamref name="TFrom"/> to another primitive type <typeparamref name="TTo"/>.
            These types may not contain pointers or references. This is checked at runtime in order to preserve type safety.
            </summary>
            <remarks>
            Supported only for platforms that support misaligned memory access.
            </remarks>
            <param name="span">The source slice, of type <typeparamref name="TFrom"/>.</param>
            <exception cref="T:System.ArgumentException">
            Thrown when <typeparamref name="TFrom"/> or <typeparamref name="TTo"/> contains pointers.
            </exception>
        </member>
        <member name="M:System.Runtime.InteropServices.MemoryMarshal.Cast``2(System.ReadOnlySpan{``0})">
            <summary>
            Casts a ReadOnlySpan of one primitive type <typeparamref name="TFrom"/> to another primitive type <typeparamref name="TTo"/>.
            These types may not contain pointers or references. This is checked at runtime in order to preserve type safety.
            </summary>
            <remarks>
            Supported only for platforms that support misaligned memory access.
            </remarks>
            <param name="span">The source slice, of type <typeparamref name="TFrom"/>.</param>
            <exception cref="T:System.ArgumentException">
            Thrown when <typeparamref name="TFrom"/> or <typeparamref name="TTo"/> contains pointers.
            </exception>
        </member>
        <member name="T:System.Runtime.InteropServices.SequenceMarshal">
            <summary>
            Provides a collection of methods for interoperating with <see cref="T:System.Buffers.ReadOnlySequence`1"/>
            </summary>
        </member>
        <member name="M:System.Runtime.InteropServices.SequenceMarshal.TryGetReadOnlySequenceSegment``1(System.Buffers.ReadOnlySequence{``0},System.Buffers.ReadOnlySequenceSegment{``0}@,System.Int32@,System.Buffers.ReadOnlySequenceSegment{``0}@,System.Int32@)">
            <summary>
            Get <see cref="T:System.Buffers.ReadOnlySequenceSegment`1"/> from the underlying <see cref="T:System.Buffers.ReadOnlySequence`1"/>.
            If unable to get the <see cref="T:System.Buffers.ReadOnlySequenceSegment`1"/>, return false.
            </summary>
        </member>
        <member name="M:System.Runtime.InteropServices.SequenceMarshal.TryGetArray``1(System.Buffers.ReadOnlySequence{``0},System.ArraySegment{``0}@)">
            <summary>
            Get an array segment from the underlying <see cref="T:System.Buffers.ReadOnlySequence`1"/>.
            If unable to get the array segment, return false with a default array segment.
            </summary>
        </member>
        <member name="M:System.Runtime.InteropServices.SequenceMarshal.TryGetReadOnlyMemory``1(System.Buffers.ReadOnlySequence{``0},System.ReadOnlyMemory{``0}@)">
            <summary>
            Get <see cref="T:System.ReadOnlyMemory`1"/> from the underlying <see cref="T:System.Buffers.ReadOnlySequence`1"/>.
            If unable to get the <see cref="T:System.ReadOnlyMemory`1"/>, return false.
            </summary>
        </member>
        <member name="M:System.Runtime.InteropServices.SequenceMarshal.TryGetString(System.Buffers.ReadOnlySequence{System.Char},System.String@,System.Int32@,System.Int32@)">
            <summary>
            Get <see cref="T:System.String"/> from the underlying <see cref="T:System.Buffers.ReadOnlySequence`1"/>.
            If unable to get the <see cref="T:System.String"/>, return false.
            </summary>
        </member>
        <member name="T:System.ArrayEx">
            <summary>
            Extensions to <see cref="T:System.Array"/> providing consistent access to APIs introduced after the type.
            </summary>
        </member>
        <member name="T:System.Buffers.ArrayPool`1">
            <summary>
            Provides a resource pool that enables reusing instances of arrays.
            </summary>
            <remarks>
            <para>
            Renting and returning buffers with an <see cref="T:System.Buffers.ArrayPool`1"/> can increase performance
            in situations where arrays are created and destroyed frequently, resulting in significant
            memory pressure on the garbage collector.
            </para>
            <para>
            This class is thread-safe.  All members may be used by multiple threads concurrently.
            </para>
            </remarks>
        </member>
        <member name="P:System.Buffers.ArrayPool`1.Shared">
            <summary>
            Retrieves a shared <see cref="T:System.Buffers.ArrayPool`1"/> instance.
            </summary>
            <remarks>
            The shared pool provides a default implementation of <see cref="T:System.Buffers.ArrayPool`1"/>
            that's intended for general applicability.  It maintains arrays of multiple sizes, and
            may hand back a larger array than was actually requested, but will never hand back a smaller
            array than was requested. Renting a buffer from it with <see cref="M:System.Buffers.ArrayPool`1.Rent(System.Int32)"/> will result in an
            existing buffer being taken from the pool if an appropriate buffer is available or in a new
            buffer being allocated if one is not available.
            byte[] and char[] are the most commonly pooled array types. For these we use a special pool type
            optimized for very fast access speeds, at the expense of more memory consumption.
            The shared pool instance is created lazily on first access.
            </remarks>
        </member>
        <member name="M:System.Buffers.ArrayPool`1.Create">
            <summary>
            Creates a new <see cref="T:System.Buffers.ArrayPool`1"/> instance using default configuration options.
            </summary>
            <returns>A new <see cref="T:System.Buffers.ArrayPool`1"/> instance.</returns>
        </member>
        <member name="M:System.Buffers.ArrayPool`1.Create(System.Int32,System.Int32)">
            <summary>
            Creates a new <see cref="T:System.Buffers.ArrayPool`1"/> instance using custom configuration options.
            </summary>
            <param name="maxArrayLength">The maximum length of array instances that may be stored in the pool.</param>
            <param name="maxArraysPerBucket">
            The maximum number of array instances that may be stored in each bucket in the pool.  The pool
            groups arrays of similar lengths into buckets for faster access.
            </param>
            <returns>A new <see cref="T:System.Buffers.ArrayPool`1"/> instance with the specified configuration options.</returns>
            <remarks>
            The created pool will group arrays into buckets, with no more than <paramref name="maxArraysPerBucket"/>
            in each bucket and with those arrays not exceeding <paramref name="maxArrayLength"/> in length.
            </remarks>
        </member>
        <member name="M:System.Buffers.ArrayPool`1.Rent(System.Int32)">
            <summary>
            Retrieves a buffer that is at least the requested length.
            </summary>
            <param name="minimumLength">The minimum length of the array needed.</param>
            <returns>
            An array that is at least <paramref name="minimumLength"/> in length.
            </returns>
            <remarks>
            This buffer is loaned to the caller and should be returned to the same pool via
            <see cref="M:System.Buffers.ArrayPool`1.Return(`0[],System.Boolean)"/> so that it may be reused in subsequent usage of <see cref="M:System.Buffers.ArrayPool`1.Rent(System.Int32)"/>.
            It is not a fatal error to not return a rented buffer, but failure to do so may lead to
            decreased application performance, as the pool may need to create a new buffer to replace
            the one lost.
            </remarks>
        </member>
        <member name="M:System.Buffers.ArrayPool`1.Return(`0[],System.Boolean)">
            <summary>
            Returns to the pool an array that was previously obtained via <see cref="M:System.Buffers.ArrayPool`1.Rent(System.Int32)"/> on the same
            <see cref="T:System.Buffers.ArrayPool`1"/> instance.
            </summary>
            <param name="array">
            The buffer previously obtained from <see cref="M:System.Buffers.ArrayPool`1.Rent(System.Int32)"/> to return to the pool.
            </param>
            <param name="clearArray">
            If <c>true</c> and if the pool will store the buffer to enable subsequent reuse, <see cref="M:System.Buffers.ArrayPool`1.Return(`0[],System.Boolean)"/>
            will clear <paramref name="array"/> of its contents so that a subsequent consumer via <see cref="M:System.Buffers.ArrayPool`1.Rent(System.Int32)"/>
            will not see the previous consumer's content.  If <c>false</c> or if the pool will release the buffer,
            the array's contents are left unchanged.
            </param>
            <remarks>
            Once a buffer has been returned to the pool, the caller gives up all ownership of the buffer
            and must not use it. The reference returned from a given call to <see cref="M:System.Buffers.ArrayPool`1.Rent(System.Int32)"/> must only be
            returned via <see cref="M:System.Buffers.ArrayPool`1.Return(`0[],System.Boolean)"/> once.  The default <see cref="T:System.Buffers.ArrayPool`1"/>
            may hold onto the returned buffer in order to rent it again, or it may release the returned buffer
            if it's determined that the pool already has enough buffers stored.
            </remarks>
        </member>
        <member name="T:System.Buffers.BuffersExtensions">
            <summary>
            Extension methods for <see cref="T:System.Buffers.ReadOnlySequence`1"/>
            </summary>
        </member>
        <member name="M:System.Buffers.BuffersExtensions.PositionOf``1(System.Buffers.ReadOnlySequence{``0}@,``0)">
            <summary>
            Returns position of first occurrence of item in the <see cref="T:System.Buffers.ReadOnlySequence`1"/>
            </summary>
        </member>
        <member name="M:System.Buffers.BuffersExtensions.CopyTo``1(System.Buffers.ReadOnlySequence{``0}@,System.Span{``0})">
            <summary>
            Copy the <see cref="T:System.Buffers.ReadOnlySequence`1"/> to the specified <see cref="T:System.Span`1"/>.
            </summary>
            <param name="source">The source <see cref="T:System.Buffers.ReadOnlySequence`1"/>.</param>
            <param name="destination">The destination <see cref="T:System.Span`1"/>.</param>
        </member>
        <member name="M:System.Buffers.BuffersExtensions.ToArray``1(System.Buffers.ReadOnlySequence{``0}@)">
            <summary>
            Converts the <see cref="T:System.Buffers.ReadOnlySequence`1"/> to an array
            </summary>
        </member>
        <member name="M:System.Buffers.BuffersExtensions.Write``1(System.Buffers.IBufferWriter{``0},System.ReadOnlySpan{``0})">
            <summary>
            Writes contents of <paramref name="value"/> to <paramref name="writer"/>
            </summary>
        </member>
        <member name="F:System.Buffers.ConfigurableArrayPool`1.DefaultMaxArrayLength">
            <summary>The default maximum length of each array in the pool (2^20).</summary>
        </member>
        <member name="F:System.Buffers.ConfigurableArrayPool`1.DefaultMaxNumberOfArraysPerBucket">
            <summary>The default maximum number of arrays per bucket that are available for rent.</summary>
        </member>
        <member name="P:System.Buffers.ConfigurableArrayPool`1.Id">
            <summary>Gets an ID for the pool to use with events.</summary>
        </member>
        <member name="T:System.Buffers.ConfigurableArrayPool`1.Bucket">
            <summary>Provides a thread-safe bucket containing buffers that can be Rent'd and Return'd.</summary>
        </member>
        <member name="M:System.Buffers.ConfigurableArrayPool`1.Bucket.#ctor(System.Int32,System.Int32,System.Int32)">
            <summary>
            Creates the pool with numberOfBuffers arrays where each buffer is of bufferLength length.
            </summary>
        </member>
        <member name="P:System.Buffers.ConfigurableArrayPool`1.Bucket.Id">
            <summary>Gets an ID for the bucket to use with events.</summary>
        </member>
        <member name="M:System.Buffers.ConfigurableArrayPool`1.Bucket.Rent">
            <summary>Takes an array from the bucket.  If the bucket is empty, returns null.</summary>
        </member>
        <member name="M:System.Buffers.ConfigurableArrayPool`1.Bucket.Return(`0[])">
            <summary>
            Attempts to return the buffer to the bucket.  If successful, the buffer will be stored
            in the bucket and true will be returned; otherwise, the buffer won't be stored, and false
            will be returned.
            </summary>
        </member>
        <member name="T:System.Buffers.IBufferWriter`1">
            <summary>
            Represents a <typeparam name="T"/> sink
            </summary>
        </member>
        <member name="M:System.Buffers.IBufferWriter`1.Advance(System.Int32)">
            <summary>
            Notifies <see cref="T:System.Buffers.IBufferWriter`1"/> that <paramref name="count"/> amount of data was written to <see cref="T:System.Span`1"/>/<see cref="T:System.Memory`1"/>
            </summary>
        </member>
        <member name="M:System.Buffers.IBufferWriter`1.GetMemory(System.Int32)">
            <summary>
            Requests the <see cref="T:System.Memory`1"/> that is at least <paramref name="sizeHint"/> in size if possible, otherwise returns maximum available memory.
            If <paramref name="sizeHint"/> is equal to <code>0</code>, currently available memory would get returned.
            </summary>
        </member>
        <member name="M:System.Buffers.IBufferWriter`1.GetSpan(System.Int32)">
            <summary>
            Requests the <see cref="T:System.Span`1"/> that is at least <paramref name="sizeHint"/> in size if possible, otherwise returns maximum available memory.
            If <paramref name="sizeHint"/> is equal to <code>0</code>, currently available memory would get returned.
            </summary>
        </member>
        <member name="T:System.Buffers.IMemoryOwner`1">
            <summary>
            Owner of Memory<typeparamref name="T"/> that is responsible for disposing the underlying memory appropriately.
            </summary>
        </member>
        <member name="P:System.Buffers.IMemoryOwner`1.Memory">
            <summary>
            Returns a Memory<typeparamref name="T"/>.
            </summary>
        </member>
        <member name="T:System.Buffers.IPinnable">
            <summary>
            Provides a mechanism for pinning and unpinning objects to prevent the GC from moving them.
            </summary>
        </member>
        <member name="M:System.Buffers.IPinnable.Pin(System.Int32)">
            <summary>
            Call this method to indicate that the IPinnable object can not be moved by the garbage collector.
            The address of the pinned object can be taken.
            <param name="elementIndex">The offset to the element within the memory at which the returned <see cref="T:System.Buffers.MemoryHandle"/> points to.</param>
            </summary>
        </member>
        <member name="M:System.Buffers.IPinnable.Unpin">
            <summary>
            Call this method to indicate that the IPinnable object no longer needs to be pinned.
            The garbage collector is free to move the object now.
            </summary>
        </member>
        <member name="T:System.Buffers.MemoryHandle">
            <summary>
            A handle for the memory.
            </summary>
        </member>
        <member name="M:System.Buffers.MemoryHandle.#ctor(System.Void*,System.Runtime.InteropServices.GCHandle,System.Buffers.IPinnable)">
            <summary>
            Creates a new memory handle for the memory.
            </summary>
            <param name="pointer">pointer to memory</param>
            <param name="pinnable">reference to manually managed object, or default if there is no memory manager</param>
            <param name="handle">handle used to pin array buffers</param>
        </member>
        <member name="P:System.Buffers.MemoryHandle.Pointer">
            <summary>
            Returns the pointer to memory, where the memory is assumed to be pinned and hence the address won't change.
            </summary>
        </member>
        <member name="M:System.Buffers.MemoryHandle.Dispose">
            <summary>
            Frees the pinned handle and releases IPinnable.
            </summary>
        </member>
        <member name="T:System.Buffers.MemoryManager`1">
            <summary>
            Manager of <see cref="T:System.Memory`1"/> that provides the implementation.
            </summary>
        </member>
        <member name="P:System.Buffers.MemoryManager`1.Memory">
            <summary>
            Returns a <see cref="T:System.Memory`1"/>.
            </summary>
        </member>
        <member name="M:System.Buffers.MemoryManager`1.GetSpan">
            <summary>
            Returns a span wrapping the underlying memory.
            </summary>
        </member>
        <member name="M:System.Buffers.MemoryManager`1.Pin(System.Int32)">
            <summary>
            Returns a handle to the memory that has been pinned and hence its address can be taken.
            </summary>
            <param name="elementIndex">The offset to the element within the memory at which the returned <see cref="T:System.Buffers.MemoryHandle"/> points to. (default = 0)</param>
        </member>
        <member name="M:System.Buffers.MemoryManager`1.Unpin">
            <summary>
            Lets the garbage collector know that the object is free to be moved now.
            </summary>
        </member>
        <member name="M:System.Buffers.MemoryManager`1.CreateMemory(System.Int32)">
            <summary>
            Returns a <see cref="T:System.Memory`1"/> for the current <see cref="T:System.Buffers.MemoryManager`1"/>.
            </summary>
            <param name="length">The element count in the memory, starting at offset 0.</param>
        </member>
        <member name="M:System.Buffers.MemoryManager`1.CreateMemory(System.Int32,System.Int32)">
            <summary>
            Returns a <see cref="T:System.Memory`1"/> for the current <see cref="T:System.Buffers.MemoryManager`1"/>.
            </summary>
            <param name="start">The offset to the element which the returned memory starts at.</param>
            <param name="length">The element count in the memory, starting at element offset <paramref name="start"/>.</param>
        </member>
        <member name="M:System.Buffers.MemoryManager`1.TryGetArray(System.ArraySegment{`0}@)">
            <summary>
            Returns an array segment.
            <remarks>Returns the default array segment if not overriden.</remarks>
            </summary>
        </member>
        <member name="M:System.Buffers.MemoryManager`1.System#IDisposable#Dispose">
            <summary>
            Implements IDisposable.
            </summary>
        </member>
        <member name="M:System.Buffers.MemoryManager`1.Dispose(System.Boolean)">
            <summary>
            Clean up of any leftover managed and unmanaged resources.
            </summary>
        </member>
        <member name="T:System.Buffers.ReadOnlySequence`1">
            <summary>
            Represents a sequence that can read a sequential series of <typeparam name="T" />.
            </summary>
        </member>
        <member name="F:System.Buffers.ReadOnlySequence`1.Empty">
            <summary>
            Returns empty <see cref="T:System.Buffers.ReadOnlySequence`1"/>
            </summary>
        </member>
        <member name="P:System.Buffers.ReadOnlySequence`1.Length">
            <summary>
            Length of the <see cref="T:System.Buffers.ReadOnlySequence`1"/>.
            </summary>
        </member>
        <member name="P:System.Buffers.ReadOnlySequence`1.IsEmpty">
            <summary>
            Determines if the <see cref="T:System.Buffers.ReadOnlySequence`1"/> is empty.
            </summary>
        </member>
        <member name="P:System.Buffers.ReadOnlySequence`1.IsSingleSegment">
            <summary>
            Determines if the <see cref="T:System.Buffers.ReadOnlySequence`1"/> contains a single <see cref="T:System.ReadOnlyMemory`1"/> segment.
            </summary>
        </member>
        <member name="P:System.Buffers.ReadOnlySequence`1.First">
            <summary>
            Gets <see cref="T:System.ReadOnlyMemory`1"/> from the first segment.
            </summary>
        </member>
        <member name="P:System.Buffers.ReadOnlySequence`1.Start">
            <summary>
            A position to the start of the <see cref="T:System.Buffers.ReadOnlySequence`1"/>.
            </summary>
        </member>
        <member name="P:System.Buffers.ReadOnlySequence`1.End">
            <summary>
            A position to the end of the <see cref="T:System.Buffers.ReadOnlySequence`1"/>
            </summary>
        </member>
        <member name="M:System.Buffers.ReadOnlySequence`1.#ctor(System.Buffers.ReadOnlySequenceSegment{`0},System.Int32,System.Buffers.ReadOnlySequenceSegment{`0},System.Int32)">
            <summary>
            Creates an instance of <see cref="T:System.Buffers.ReadOnlySequence`1"/> from linked memory list represented by start and end segments
            and corresponding indexes in them.
            </summary>
        </member>
        <member name="M:System.Buffers.ReadOnlySequence`1.#ctor(`0[])">
            <summary>
            Creates an instance of <see cref="T:System.Buffers.ReadOnlySequence`1"/> from the <see cref="!:T[]"/>.
            </summary>
        </member>
        <member name="M:System.Buffers.ReadOnlySequence`1.#ctor(`0[],System.Int32,System.Int32)">
            <summary>
            Creates an instance of <see cref="T:System.Buffers.ReadOnlySequence`1"/> from the <see cref="!:T[]"/>, start and index.
            </summary>
        </member>
        <member name="M:System.Buffers.ReadOnlySequence`1.#ctor(System.ReadOnlyMemory{`0})">
            <summary>
            Creates an instance of <see cref="T:System.Buffers.ReadOnlySequence`1"/> from the <see cref="T:System.ReadOnlyMemory`1"/>.
            Consumer is expected to manage lifetime of memory until <see cref="T:System.Buffers.ReadOnlySequence`1"/> is not used anymore.
            </summary>
        </member>
        <member name="M:System.Buffers.ReadOnlySequence`1.Slice(System.Int64,System.Int64)">
            <summary>
            Forms a slice out of the given <see cref="T:System.Buffers.ReadOnlySequence`1"/>, beginning at <paramref name="start"/>, with <paramref name="length"/> items
            </summary>
            <param name="start">The index at which to begin this slice.</param>
            <param name="length">The length of the slice</param>
        </member>
        <member name="M:System.Buffers.ReadOnlySequence`1.Slice(System.Int64,System.SequencePosition)">
            <summary>
            Forms a slice out of the given <see cref="T:System.Buffers.ReadOnlySequence`1"/>, beginning at <paramref name="start"/>, ending at <paramref name="end"/> (inclusive).
            </summary>
            <param name="start">The index at which to begin this slice.</param>
            <param name="end">The end (inclusive) of the slice</param>
        </member>
        <member name="M:System.Buffers.ReadOnlySequence`1.Slice(System.SequencePosition,System.Int64)">
            <summary>
            Forms a slice out of the given <see cref="T:System.Buffers.ReadOnlySequence`1"/>, beginning at <paramref name="start"/>, with <paramref name="length"/> items
            </summary>
            <param name="start">The starting (inclusive) <see cref="T:System.SequencePosition"/> at which to begin this slice.</param>
            <param name="length">The length of the slice</param>
        </member>
        <member name="M:System.Buffers.ReadOnlySequence`1.Slice(System.Int32,System.Int32)">
            <summary>
            Forms a slice out of the given <see cref="T:System.Buffers.ReadOnlySequence`1"/>, beginning at <paramref name="start"/>, with <paramref name="length"/> items
            </summary>
            <param name="start">The index at which to begin this slice.</param>
            <param name="length">The length of the slice</param>
        </member>
        <member name="M:System.Buffers.ReadOnlySequence`1.Slice(System.Int32,System.SequencePosition)">
            <summary>
            Forms a slice out of the given <see cref="T:System.Buffers.ReadOnlySequence`1"/>, beginning at <paramref name="start"/>, ending at <paramref name="end"/> (inclusive).
            </summary>
            <param name="start">The index at which to begin this slice.</param>
            <param name="end">The end (inclusive) of the slice</param>
        </member>
        <member name="M:System.Buffers.ReadOnlySequence`1.Slice(System.SequencePosition,System.Int32)">
            <summary>
            Forms a slice out of the given <see cref="T:System.Buffers.ReadOnlySequence`1"/>, beginning at '<paramref name="start"/>, with <paramref name="length"/> items
            </summary>
            <param name="start">The starting (inclusive) <see cref="T:System.SequencePosition"/> at which to begin this slice.</param>
            <param name="length">The length of the slice</param>
        </member>
        <member name="M:System.Buffers.ReadOnlySequence`1.Slice(System.SequencePosition,System.SequencePosition)">
            <summary>
            Forms a slice out of the given <see cref="T:System.Buffers.ReadOnlySequence`1"/>, beginning at <paramref name="start"/>, ending at <paramref name="end"/> (inclusive).
            </summary>
            <param name="start">The starting (inclusive) <see cref="T:System.SequencePosition"/> at which to begin this slice.</param>
            <param name="end">The ending (inclusive) <see cref="T:System.SequencePosition"/> of the slice</param>
        </member>
        <member name="M:System.Buffers.ReadOnlySequence`1.Slice(System.SequencePosition)">
            <summary>
            Forms a slice out of the given <see cref="T:System.Buffers.ReadOnlySequence`1"/>, beginning at <paramref name="start"/>, ending at the existing <see cref="T:System.Buffers.ReadOnlySequence`1"/>'s end.
            </summary>
            <param name="start">The starting (inclusive) <see cref="T:System.SequencePosition"/> at which to begin this slice.</param>
        </member>
        <member name="M:System.Buffers.ReadOnlySequence`1.Slice(System.Int64)">
            <summary>
            Forms a slice out of the given <see cref="T:System.Buffers.ReadOnlySequence`1"/>, beginning at <paramref name="start"/>, ending at the existing <see cref="T:System.Buffers.ReadOnlySequence`1"/>'s end.
            </summary>
            <param name="start">The start index at which to begin this slice.</param>
        </member>
        <member name="M:System.Buffers.ReadOnlySequence`1.ToString">
            <inheritdoc />
        </member>
        <member name="M:System.Buffers.ReadOnlySequence`1.GetEnumerator">
            <summary>
            Returns an enumerator over the <see cref="T:System.Buffers.ReadOnlySequence`1"/>
            </summary>
        </member>
        <member name="M:System.Buffers.ReadOnlySequence`1.GetPosition(System.Int64)">
            <summary>
            Returns a new <see cref="T:System.SequencePosition"/> at an <paramref name="offset"/> from the start of the sequence.
            </summary>
        </member>
        <member name="M:System.Buffers.ReadOnlySequence`1.GetPosition(System.Int64,System.SequencePosition)">
            <summary>
            Returns a new <see cref="T:System.SequencePosition"/> at an <paramref name="offset"/> from the <paramref name="origin"/>
            </summary>
        </member>
        <member name="M:System.Buffers.ReadOnlySequence`1.TryGet(System.SequencePosition@,System.ReadOnlyMemory{`0}@,System.Boolean)">
            <summary>
            Tries to retrieve next segment after <paramref name="position"/> and return its contents in <paramref name="memory"/>.
            Returns <code>false</code> if end of <see cref="T:System.Buffers.ReadOnlySequence`1"/> was reached otherwise <code>true</code>.
            Sets <paramref name="position"/> to the beginning of next segment if <paramref name="advance"/> is set to <code>true</code>.
            </summary>
        </member>
        <member name="T:System.Buffers.ReadOnlySequence`1.Enumerator">
            <summary>
            An enumerator over the <see cref="T:System.Buffers.ReadOnlySequence`1"/>
            </summary>
        </member>
        <member name="M:System.Buffers.ReadOnlySequence`1.Enumerator.#ctor(System.Buffers.ReadOnlySequence{`0}@)">
            <summary>Initialize the enumerator.</summary>
            <param name="sequence">The <see cref="T:System.Buffers.ReadOnlySequence`1"/> to enumerate.</param>
        </member>
        <member name="P:System.Buffers.ReadOnlySequence`1.Enumerator.Current">
            <summary>
            The current <see cref="T:System.ReadOnlyMemory`1"/>
            </summary>
        </member>
        <member name="M:System.Buffers.ReadOnlySequence`1.Enumerator.MoveNext">
            <summary>
            Moves to the next <see cref="T:System.ReadOnlyMemory`1"/> in the <see cref="T:System.Buffers.ReadOnlySequence`1"/>
            </summary>
            <returns></returns>
        </member>
        <member name="T:System.Buffers.ReadOnlySequenceSegment`1">
            <summary>
            Represents a linked list of <see cref="T:System.ReadOnlyMemory`1"/> nodes.
            </summary>
        </member>
        <member name="P:System.Buffers.ReadOnlySequenceSegment`1.Memory">
            <summary>
            The <see cref="T:System.ReadOnlyMemory`1"/> value for current node.
            </summary>
        </member>
        <member name="P:System.Buffers.ReadOnlySequenceSegment`1.Next">
            <summary>
            The next node.
            </summary>
        </member>
        <member name="P:System.Buffers.ReadOnlySequenceSegment`1.RunningIndex">
            <summary>
            The sum of node length before current.
            </summary>
        </member>
        <member name="T:System.Buffers.StandardFormat">
            <summary>
            Represents a standard formatting string without using an actual String. A StandardFormat consists of a character (such as 'G', 'D' or 'X')
            and an optional precision ranging from 0..99, or the special value NoPrecision.
            </summary>
        </member>
        <member name="F:System.Buffers.StandardFormat.NoPrecision">
            <summary>
            Precision values for format that don't use a precision, or for when the precision is to be unspecified.
            </summary>
        </member>
        <member name="F:System.Buffers.StandardFormat.MaxPrecision">
            <summary>
            The maximum valid precision value.
            </summary>
        </member>
        <member name="P:System.Buffers.StandardFormat.Symbol">
            <summary>
            The character component of the format.
            </summary>
        </member>
        <member name="P:System.Buffers.StandardFormat.Precision">
            <summary>
            The precision component of the format. Ranges from 0..9 or the special value NoPrecision.
            </summary>
        </member>
        <member name="P:System.Buffers.StandardFormat.HasPrecision">
            <summary>
            true if Precision is a value other than NoPrecision
            </summary>
        </member>
        <member name="P:System.Buffers.StandardFormat.IsDefault">
            <summary>
            true if the StandardFormat == default(StandardFormat)
            </summary>
        </member>
        <member name="M:System.Buffers.StandardFormat.#ctor(System.Char,System.Byte)">
            <summary>
            Create a StandardFormat.
            </summary>
            <param name="symbol">A type-specific formatting character such as 'G', 'D' or 'X'</param>
            <param name="precision">An optional precision ranging from 0..9 or the special value NoPrecision (the default)</param>
        </member>
        <member name="M:System.Buffers.StandardFormat.op_Implicit(System.Char)~System.Buffers.StandardFormat">
            <summary>
            Converts a character to a StandardFormat using the NoPrecision precision.
            </summary>
        </member>
        <member name="M:System.Buffers.StandardFormat.Parse(System.ReadOnlySpan{System.Char})">
            <summary>
            Converts a classic .NET format string into a StandardFormat
            </summary>
        </member>
        <member name="M:System.Buffers.StandardFormat.Parse(System.String)">
            <summary>
            Converts a classic .NET format string into a StandardFormat
            </summary>
        </member>
        <member name="M:System.Buffers.StandardFormat.Equals(System.Object)">
            <summary>
            Returns true if both the Symbol and Precision are equal.
            </summary>
        </member>
        <member name="M:System.Buffers.StandardFormat.GetHashCode">
            <summary>
            Compute a hash code.
            </summary>
        </member>
        <member name="M:System.Buffers.StandardFormat.Equals(System.Buffers.StandardFormat)">
            <summary>
            Returns true if both the Symbol and Precision are equal.
            </summary>
        </member>
        <member name="M:System.Buffers.StandardFormat.ToString">
            <summary>
            Returns the format in classic .NET format.
            </summary>
        </member>
        <member name="M:System.Buffers.StandardFormat.op_Equality(System.Buffers.StandardFormat,System.Buffers.StandardFormat)">
            <summary>
            Returns true if both the Symbol and Precision are equal.
            </summary>
        </member>
        <member name="M:System.Buffers.StandardFormat.op_Inequality(System.Buffers.StandardFormat,System.Buffers.StandardFormat)">
            <summary>
            Returns false if both the Symbol and Precision are equal.
            </summary>
        </member>
        <member name="T:System.Buffers.TlsOverPerCoreLockedStacksArrayPool`1">
            <summary>
            Provides an ArrayPool implementation meant to be used as the singleton returned from ArrayPool.Shared.
            </summary>
            <remarks>
            The implementation uses a tiered caching scheme, with a small per-thread cache for each array size, followed
            by a cache per array size shared by all threads, split into per-core stacks meant to be used by threads
            running on that core.  Locks are used to protect each per-core stack, because a thread can migrate after
            checking its processor number, because multiple threads could interleave on the same core, and because
            a thread is allowed to check other core's buckets if its core's bucket is empty/full.
            </remarks>
        </member>
        <member name="F:System.Buffers.TlsOverPerCoreLockedStacksArrayPool`1.NumBuckets">
            <summary>The number of buckets (array sizes) in the pool, one for each array length, starting from length 16.</summary>
        </member>
        <member name="F:System.Buffers.TlsOverPerCoreLockedStacksArrayPool`1.MaxPerCorePerArraySizeStacks">
            <summary>Maximum number of per-core stacks to use per array size.</summary>
        </member>
        <member name="F:System.Buffers.TlsOverPerCoreLockedStacksArrayPool`1.MaxBuffersPerArraySizePerCore">
            <summary>The maximum number of buffers to store in a bucket's global queue.</summary>
        </member>
        <member name="F:System.Buffers.TlsOverPerCoreLockedStacksArrayPool`1.t_tlsBuckets">
            <summary>A per-thread array of arrays, to cache one array per array size per thread.</summary>
        </member>
        <member name="F:System.Buffers.TlsOverPerCoreLockedStacksArrayPool`1._allTlsBuckets">
            <summary>Used to keep track of all thread local buckets for trimming if needed.</summary>
        </member>
        <member name="F:System.Buffers.TlsOverPerCoreLockedStacksArrayPool`1._buckets">
            <summary>
            An array of per-core array stacks. The slots are lazily initialized to avoid creating
            lots of overhead for unused array sizes.
            </summary>
        </member>
        <member name="F:System.Buffers.TlsOverPerCoreLockedStacksArrayPool`1._trimCallbackCreated">
            <summary>Whether the callback to trim arrays in response to memory pressure has been created.</summary>
        </member>
        <member name="M:System.Buffers.TlsOverPerCoreLockedStacksArrayPool`1.CreatePerCoreLockedStacks(System.Int32)">
            <summary>Allocate a new PerCoreLockedStacks and try to store it into the <see cref="F:System.Buffers.TlsOverPerCoreLockedStacksArrayPool`1._buckets"/> array.</summary>
        </member>
        <member name="P:System.Buffers.TlsOverPerCoreLockedStacksArrayPool`1.Id">
            <summary>Gets an ID for the pool to use with events.</summary>
        </member>
        <member name="T:System.Buffers.TlsOverPerCoreLockedStacksArrayPool`1.PerCoreLockedStacks">
            <summary>Stores a set of stacks of arrays, with one stack per core.</summary>
        </member>
        <member name="F:System.Buffers.TlsOverPerCoreLockedStacksArrayPool`1.PerCoreLockedStacks.s_lockedStackCount">
            <summary>Number of locked stacks to employ.</summary>
        </member>
        <member name="F:System.Buffers.TlsOverPerCoreLockedStacksArrayPool`1.PerCoreLockedStacks._perCoreStacks">
            <summary>The stacks.</summary>
        </member>
        <member name="M:System.Buffers.TlsOverPerCoreLockedStacksArrayPool`1.PerCoreLockedStacks.#ctor">
            <summary>Initializes the stacks.</summary>
        </member>
        <member name="M:System.Buffers.TlsOverPerCoreLockedStacksArrayPool`1.PerCoreLockedStacks.TryPush(`0[])">
            <summary>Try to push the array into the stacks. If each is full when it's tested, the array will be dropped.</summary>
        </member>
        <member name="M:System.Buffers.TlsOverPerCoreLockedStacksArrayPool`1.PerCoreLockedStacks.TryPop">
            <summary>Try to get an array from the stacks.  If each is empty when it's tested, null will be returned.</summary>
        </member>
        <member name="T:System.Buffers.TlsOverPerCoreLockedStacksArrayPool`1.LockedStack">
            <summary>Provides a simple, bounded stack of arrays, protected by a lock.</summary>
        </member>
        <member name="F:System.Buffers.TlsOverPerCoreLockedStacksArrayPool`1.LockedStack._arrays">
            <summary>The arrays in the stack.</summary>
        </member>
        <member name="F:System.Buffers.TlsOverPerCoreLockedStacksArrayPool`1.LockedStack._count">
            <summary>Number of arrays stored in <see cref="F:System.Buffers.TlsOverPerCoreLockedStacksArrayPool`1.LockedStack._arrays"/>.</summary>
        </member>
        <member name="F:System.Buffers.TlsOverPerCoreLockedStacksArrayPool`1.LockedStack._millisecondsTimestamp">
            <summary>Timestamp set by Trim when it sees this as 0.</summary>
        </member>
        <member name="T:System.Buffers.TlsOverPerCoreLockedStacksArrayPool`1.ThreadLocalArray">
            <summary>Wrapper for arrays stored in ThreadStatic buckets.</summary>
        </member>
        <member name="F:System.Buffers.TlsOverPerCoreLockedStacksArrayPool`1.ThreadLocalArray.Array">
            <summary>The stored array.</summary>
        </member>
        <member name="F:System.Buffers.TlsOverPerCoreLockedStacksArrayPool`1.ThreadLocalArray.MillisecondsTimeStamp">
            <summary>Environment.TickCount timestamp for when this array was observed by Trim.</summary>
        </member>
        <member name="T:System.SequencePosition">
            <summary>
            Represents position in non-contiguous set of memory.
            Properties of this type should not be interpreted by anything but the type that created it.
            </summary>
        </member>
        <member name="M:System.SequencePosition.#ctor(System.Object,System.Int32)">
            <summary>
            Creates new <see cref="T:System.SequencePosition"/>
            </summary>
        </member>
        <member name="M:System.SequencePosition.GetObject">
            <summary>
            Returns object part of this <see cref="T:System.SequencePosition"/>
            </summary>
        </member>
        <member name="M:System.SequencePosition.GetInteger">
            <summary>
            Returns integer part of this <see cref="T:System.SequencePosition"/>
            </summary>
        </member>
        <member name="M:System.SequencePosition.Equals(System.SequencePosition)">
            <summary>
            Indicates whether the current <see cref="T:System.SequencePosition"/> is equal to another <see cref="T:System.SequencePosition"/>.
            <see cref="T:System.SequencePosition"/> equality does not guarantee that they point to the same location in <see cref="T:System.Buffers.ReadOnlySequence`1" />
            </summary>
        </member>
        <member name="M:System.SequencePosition.Equals(System.Object)">
            <summary>
            Indicates whether the current <see cref="T:System.SequencePosition"/> is equal to another <see cref="T:System.Object"/>.
            <see cref="T:System.SequencePosition"/> equality does not guarantee that they point to the same location in <see cref="T:System.Buffers.ReadOnlySequence`1" />
            </summary>
        </member>
        <member name="M:System.SequencePosition.GetHashCode">
            <inheritdoc />
        </member>
        <member name="M:System.Collections.HashHelpers.GetFastModMultiplier(System.UInt32)">
            <summary>Returns approximate reciprocal of the divisor: ceil(2**64 / divisor).</summary>
            <remarks>This should only be used on 64-bit.</remarks>
        </member>
        <member name="M:System.Collections.HashHelpers.FastMod(System.UInt32,System.UInt32,System.UInt64)">
            <summary>Performs a mod operation using the multiplier pre-computed with <see cref="M:System.Collections.HashHelpers.GetFastModMultiplier(System.UInt32)"/>.</summary>
            <remarks>This should only be used on 64-bit.</remarks>
        </member>
        <member name="T:System.Gen2GcCallback">
            <summary>
            Schedules a callback roughly every gen 2 GC (you may see a Gen 0 an Gen 1 but only once)
            (We can fix this by capturing the Gen 2 count at startup and testing, but I mostly don't care)
            </summary>
        </member>
        <member name="M:System.Gen2GcCallback.Register(System.Func{System.Boolean})">
            <summary>
            Schedule 'callback' to be called in the next GC.  If the callback returns true it is
            rescheduled for the next Gen 2 GC.  Otherwise the callbacks stop.
            </summary>
        </member>
        <member name="M:System.Gen2GcCallback.Register(System.Func{System.Object,System.Boolean},System.Object)">
             <summary>
             Schedule 'callback' to be called in the next GC.  If the callback returns true it is
             rescheduled for the next Gen 2 GC.  Otherwise the callbacks stop.
            
             NOTE: This callback will be kept alive until either the callback function returns false,
             or the target object dies.
             </summary>
        </member>
        <member name="M:System.HashCode.AddBytes(System.ReadOnlySpan{System.Byte})">
            <summary>Adds a span of bytes to the hash code.</summary>
            <param name="value">The span.</param>
            <remarks>
            This method does not guarantee that the result of adding a span of bytes will match
            the result of adding the same bytes individually.
            </remarks>
        </member>
        <member name="T:System.MathEx">
            <summary>
            Extensions to <see cref="T:System.StringComparer"/> providing consistent access to APIs introduced after the type.
            </summary>
        </member>
        <member name="M:System.MathEx.Clamp(System.Byte,System.Byte,System.Byte)">
             <summary>Returns <paramref name="value" /> clamped to the inclusive range of <paramref name="min" /> and <paramref name="max" />.</summary>
             <param name="value">The value to be clamped.</param>
             <param name="min">The lower bound of the result.</param>
             <param name="max">The upper bound of the result.</param>
             <returns>
               <paramref name="value" /> if <paramref name="min" /> ≤ <paramref name="value" /> ≤ <paramref name="max" />.
            
               -or-
            
               <paramref name="min" /> if <paramref name="value" /> &lt; <paramref name="min" />.
            
               -or-
            
               <paramref name="max" /> if <paramref name="max" /> &lt; <paramref name="value" />.
             </returns>
        </member>
        <member name="M:System.MathEx.Clamp(System.Decimal,System.Decimal,System.Decimal)">
             <summary>Returns <paramref name="value" /> clamped to the inclusive range of <paramref name="min" /> and <paramref name="max" />.</summary>
             <param name="value">The value to be clamped.</param>
             <param name="min">The lower bound of the result.</param>
             <param name="max">The upper bound of the result.</param>
             <returns>
               <paramref name="value" /> if <paramref name="min" /> ≤ <paramref name="value" /> ≤ <paramref name="max" />.
            
               -or-
            
               <paramref name="min" /> if <paramref name="value" /> &lt; <paramref name="min" />.
            
               -or-
            
               <paramref name="max" /> if <paramref name="max" /> &lt; <paramref name="value" />.
             </returns>
        </member>
        <member name="M:System.MathEx.Clamp(System.Double,System.Double,System.Double)">
             <summary>Returns <paramref name="value" /> clamped to the inclusive range of <paramref name="min" /> and <paramref name="max" />.</summary>
             <param name="value">The value to be clamped.</param>
             <param name="min">The lower bound of the result.</param>
             <param name="max">The upper bound of the result.</param>
             <returns>
               <paramref name="value" /> if <paramref name="min" /> ≤ <paramref name="value" /> ≤ <paramref name="max" />.
            
               -or-
            
               <paramref name="min" /> if <paramref name="value" /> &lt; <paramref name="min" />.
            
               -or-
            
               <paramref name="max" /> if <paramref name="max" /> &lt; <paramref name="value" />.
             </returns>
        </member>
        <member name="M:System.MathEx.Clamp(System.Int16,System.Int16,System.Int16)">
             <summary>Returns <paramref name="value" /> clamped to the inclusive range of <paramref name="min" /> and <paramref name="max" />.</summary>
             <param name="value">The value to be clamped.</param>
             <param name="min">The lower bound of the result.</param>
             <param name="max">The upper bound of the result.</param>
             <returns>
               <paramref name="value" /> if <paramref name="min" /> ≤ <paramref name="value" /> ≤ <paramref name="max" />.
            
               -or-
            
               <paramref name="min" /> if <paramref name="value" /> &lt; <paramref name="min" />.
            
               -or-
            
               <paramref name="max" /> if <paramref name="max" /> &lt; <paramref name="value" />.
             </returns>
        </member>
        <member name="M:System.MathEx.Clamp(System.Int32,System.Int32,System.Int32)">
             <summary>Returns <paramref name="value" /> clamped to the inclusive range of <paramref name="min" /> and <paramref name="max" />.</summary>
             <param name="value">The value to be clamped.</param>
             <param name="min">The lower bound of the result.</param>
             <param name="max">The upper bound of the result.</param>
             <returns>
               <paramref name="value" /> if <paramref name="min" /> ≤ <paramref name="value" /> ≤ <paramref name="max" />.
            
               -or-
            
               <paramref name="min" /> if <paramref name="value" /> &lt; <paramref name="min" />.
            
               -or-
            
               <paramref name="max" /> if <paramref name="max" /> &lt; <paramref name="value" />.
             </returns>
        </member>
        <member name="M:System.MathEx.Clamp(System.Int64,System.Int64,System.Int64)">
             <summary>Returns <paramref name="value" /> clamped to the inclusive range of <paramref name="min" /> and <paramref name="max" />.</summary>
             <param name="value">The value to be clamped.</param>
             <param name="min">The lower bound of the result.</param>
             <param name="max">The upper bound of the result.</param>
             <returns>
               <paramref name="value" /> if <paramref name="min" /> ≤ <paramref name="value" /> ≤ <paramref name="max" />.
            
               -or-
            
               <paramref name="min" /> if <paramref name="value" /> &lt; <paramref name="min" />.
            
               -or-
            
               <paramref name="max" /> if <paramref name="max" /> &lt; <paramref name="value" />.
             </returns>
        </member>
        <member name="M:System.MathEx.Clamp(System.IntPtr,System.IntPtr,System.IntPtr)">
             <summary>Returns <paramref name="value" /> clamped to the inclusive range of <paramref name="min" /> and <paramref name="max" />.</summary>
             <param name="value">The value to be clamped.</param>
             <param name="min">The lower bound of the result.</param>
             <param name="max">The upper bound of the result.</param>
             <returns>
               <paramref name="value" /> if <paramref name="min" /> ≤ <paramref name="value" /> ≤ <paramref name="max" />.
            
               -or-
            
               <paramref name="min" /> if <paramref name="value" /> &lt; <paramref name="min" />.
            
               -or-
            
               <paramref name="max" /> if <paramref name="max" /> &lt; <paramref name="value" />.
             </returns>
        </member>
        <member name="M:System.MathEx.Clamp(System.SByte,System.SByte,System.SByte)">
             <summary>Returns <paramref name="value" /> clamped to the inclusive range of <paramref name="min" /> and <paramref name="max" />.</summary>
             <param name="value">The value to be clamped.</param>
             <param name="min">The lower bound of the result.</param>
             <param name="max">The upper bound of the result.</param>
             <returns>
               <paramref name="value" /> if <paramref name="min" /> ≤ <paramref name="value" /> ≤ <paramref name="max" />.
            
               -or-
            
               <paramref name="min" /> if <paramref name="value" /> &lt; <paramref name="min" />.
            
               -or-
            
               <paramref name="max" /> if <paramref name="max" /> &lt; <paramref name="value" />.
             </returns>
        </member>
        <member name="M:System.MathEx.Clamp(System.Single,System.Single,System.Single)">
             <summary>Returns <paramref name="value" /> clamped to the inclusive range of <paramref name="min" /> and <paramref name="max" />.</summary>
             <param name="value">The value to be clamped.</param>
             <param name="min">The lower bound of the result.</param>
             <param name="max">The upper bound of the result.</param>
             <returns>
               <paramref name="value" /> if <paramref name="min" /> ≤ <paramref name="value" /> ≤ <paramref name="max" />.
            
               -or-
            
               <paramref name="min" /> if <paramref name="value" /> &lt; <paramref name="min" />.
            
               -or-
            
               <paramref name="max" /> if <paramref name="max" /> &lt; <paramref name="value" />.
             </returns>
        </member>
        <member name="M:System.MathEx.Clamp(System.UInt16,System.UInt16,System.UInt16)">
             <summary>Returns <paramref name="value" /> clamped to the inclusive range of <paramref name="min" /> and <paramref name="max" />.</summary>
             <param name="value">The value to be clamped.</param>
             <param name="min">The lower bound of the result.</param>
             <param name="max">The upper bound of the result.</param>
             <returns>
               <paramref name="value" /> if <paramref name="min" /> ≤ <paramref name="value" /> ≤ <paramref name="max" />.
            
               -or-
            
               <paramref name="min" /> if <paramref name="value" /> &lt; <paramref name="min" />.
            
               -or-
            
               <paramref name="max" /> if <paramref name="max" /> &lt; <paramref name="value" />.
             </returns>
        </member>
        <member name="M:System.MathEx.Clamp(System.UInt32,System.UInt32,System.UInt32)">
             <summary>Returns <paramref name="value" /> clamped to the inclusive range of <paramref name="min" /> and <paramref name="max" />.</summary>
             <param name="value">The value to be clamped.</param>
             <param name="min">The lower bound of the result.</param>
             <param name="max">The upper bound of the result.</param>
             <returns>
               <paramref name="value" /> if <paramref name="min" /> ≤ <paramref name="value" /> ≤ <paramref name="max" />.
            
               -or-
            
               <paramref name="min" /> if <paramref name="value" /> &lt; <paramref name="min" />.
            
               -or-
            
               <paramref name="max" /> if <paramref name="max" /> &lt; <paramref name="value" />.
             </returns>
        </member>
        <member name="M:System.MathEx.Clamp(System.UInt64,System.UInt64,System.UInt64)">
             <summary>Returns <paramref name="value" /> clamped to the inclusive range of <paramref name="min" /> and <paramref name="max" />.</summary>
             <param name="value">The value to be clamped.</param>
             <param name="min">The lower bound of the result.</param>
             <param name="max">The upper bound of the result.</param>
             <returns>
               <paramref name="value" /> if <paramref name="min" /> ≤ <paramref name="value" /> ≤ <paramref name="max" />.
            
               -or-
            
               <paramref name="min" /> if <paramref name="value" /> &lt; <paramref name="min" />.
            
               -or-
            
               <paramref name="max" /> if <paramref name="max" /> &lt; <paramref name="value" />.
             </returns>
        </member>
        <member name="M:System.MathEx.Clamp(System.UIntPtr,System.UIntPtr,System.UIntPtr)">
             <summary>Returns <paramref name="value" /> clamped to the inclusive range of <paramref name="min" /> and <paramref name="max" />.</summary>
             <param name="value">The value to be clamped.</param>
             <param name="min">The lower bound of the result.</param>
             <param name="max">The upper bound of the result.</param>
             <returns>
               <paramref name="value" /> if <paramref name="min" /> ≤ <paramref name="value" /> ≤ <paramref name="max" />.
            
               -or-
            
               <paramref name="min" /> if <paramref name="value" /> &lt; <paramref name="min" />.
            
               -or-
            
               <paramref name="max" /> if <paramref name="max" /> &lt; <paramref name="value" />.
             </returns>
        </member>
        <member name="T:System.Memory`1">
            <summary>
            Memory represents a contiguous region of arbitrary memory similar to <see cref="T:System.Span`1"/>.
            Unlike <see cref="T:System.Span`1"/>, it is not a byref-like type.
            </summary>
        </member>
        <member name="M:System.Memory`1.#ctor(`0[])">
            <summary>
            Creates a new memory over the entirety of the target array.
            </summary>
            <param name="array">The target array.</param>
            <remarks>Returns default when <paramref name="array"/> is null.</remarks>
            <exception cref="T:System.ArrayTypeMismatchException">Thrown when <paramref name="array"/> is covariant and array's type is not exactly T[].</exception>
        </member>
        <member name="M:System.Memory`1.#ctor(`0[],System.Int32,System.Int32)">
            <summary>
            Creates a new memory over the portion of the target array beginning
            at 'start' index and ending at 'end' index (exclusive).
            </summary>
            <param name="array">The target array.</param>
            <param name="start">The index at which to begin the memory.</param>
            <param name="length">The number of items in the memory.</param>
            <remarks>Returns default when <paramref name="array"/> is null.</remarks>
            <exception cref="T:System.ArrayTypeMismatchException">Thrown when <paramref name="array"/> is covariant and array's type is not exactly T[].</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">
            Thrown when the specified <paramref name="start"/> or end index is not in the range (&lt;0 or &gt;=Length).
            </exception>
        </member>
        <member name="M:System.Memory`1.#ctor(System.Buffers.MemoryManager{`0},System.Int32)">
            <summary>
            Creates a new memory from a memory manager that provides specific method implementations beginning
            at 0 index and ending at 'end' index (exclusive).
            </summary>
            <param name="manager">The memory manager.</param>
            <param name="length">The number of items in the memory.</param>
            <exception cref="T:System.ArgumentOutOfRangeException">
            Thrown when the specified <paramref name="length"/> is negative.
            </exception>
            <remarks>For internal infrastructure only</remarks>
        </member>
        <member name="M:System.Memory`1.#ctor(System.Buffers.MemoryManager{`0},System.Int32,System.Int32)">
            <summary>
            Creates a new memory from a memory manager that provides specific method implementations beginning
            at 'start' index and ending at 'end' index (exclusive).
            </summary>
            <param name="manager">The memory manager.</param>
            <param name="start">The index at which to begin the memory.</param>
            <param name="length">The number of items in the memory.</param>
            <exception cref="T:System.ArgumentOutOfRangeException">
            Thrown when the specified <paramref name="start"/> or <paramref name="length"/> is negative.
            </exception>
            <remarks>For internal infrastructure only</remarks>
        </member>
        <member name="M:System.Memory`1.op_Implicit(`0[])~System.Memory{`0}">
            <summary>
            Defines an implicit conversion of an array to a <see cref="T:System.Memory`1"/>
            </summary>
        </member>
        <member name="M:System.Memory`1.op_Implicit(System.ArraySegment{`0})~System.Memory{`0}">
            <summary>
            Defines an implicit conversion of a <see cref="T:System.ArraySegment`1"/> to a <see cref="T:System.Memory`1"/>
            </summary>
        </member>
        <member name="M:System.Memory`1.op_Implicit(System.Memory{`0})~System.ReadOnlyMemory{`0}">
            <summary>
            Defines an implicit conversion of a <see cref="T:System.Memory`1"/> to a <see cref="T:System.ReadOnlyMemory`1"/>
            </summary>
        </member>
        <member name="P:System.Memory`1.Empty">
            <summary>
            Returns an empty <see cref="T:System.Memory`1"/>
            </summary>
        </member>
        <member name="P:System.Memory`1.Length">
            <summary>
            The number of items in the memory.
            </summary>
        </member>
        <member name="P:System.Memory`1.IsEmpty">
            <summary>
            Returns true if Length is 0.
            </summary>
        </member>
        <member name="M:System.Memory`1.ToString">
            <summary>
            For <see cref="T:System.Memory`1"/>, returns a new instance of string that represents the characters pointed to by the memory.
            Otherwise, returns a <see cref="T:System.String"/> with the name of the type and the number of elements.
            </summary>
        </member>
        <member name="M:System.Memory`1.Slice(System.Int32)">
            <summary>
            Forms a slice out of the given memory, beginning at 'start'.
            </summary>
            <param name="start">The index at which to begin this slice.</param>
            <exception cref="T:System.ArgumentOutOfRangeException">
            Thrown when the specified <paramref name="start"/> index is not in range (&lt;0 or &gt;=Length).
            </exception>
        </member>
        <member name="M:System.Memory`1.Slice(System.Int32,System.Int32)">
            <summary>
            Forms a slice out of the given memory, beginning at 'start', of given length
            </summary>
            <param name="start">The index at which to begin this slice.</param>
            <param name="length">The desired length for the slice (exclusive).</param>
            <exception cref="T:System.ArgumentOutOfRangeException">
            Thrown when the specified <paramref name="start"/> or end index is not in range (&lt;0 or &gt;=Length).
            </exception>
        </member>
        <member name="P:System.Memory`1.Span">
            <summary>
            Returns a span from the memory.
            </summary>
        </member>
        <member name="M:System.Memory`1.CopyTo(System.Memory{`0})">
             <summary>
             Copies the contents of the memory into the destination. If the source
             and destination overlap, this method behaves as if the original values are in
             a temporary location before the destination is overwritten.
            
             <param name="destination">The Memory to copy items into.</param>
             <exception cref="T:System.ArgumentException">
             Thrown when the destination is shorter than the source.
             </exception>
             </summary>
        </member>
        <member name="M:System.Memory`1.TryCopyTo(System.Memory{`0})">
             <summary>
             Copies the contents of the memory into the destination. If the source
             and destination overlap, this method behaves as if the original values are in
             a temporary location before the destination is overwritten.
            
             <returns>If the destination is shorter than the source, this method
             return false and no data is written to the destination.</returns>
             </summary>
             <param name="destination">The span to copy items into.</param>
        </member>
        <member name="M:System.Memory`1.Pin">
            <summary>
            Creates a handle for the memory.
            The GC will not move the memory until the returned <see cref="T:System.Buffers.MemoryHandle"/>
            is disposed, enabling taking and using the memory's address.
            <exception cref="T:System.ArgumentException">
            An instance with nonprimitive (non-blittable) members cannot be pinned.
            </exception>
            </summary>
        </member>
        <member name="M:System.Memory`1.ToArray">
            <summary>
            Copies the contents from the memory into a new array.  This heap
            allocates, so should generally be avoided, however it is sometimes
            necessary to bridge the gap with APIs written in terms of arrays.
            </summary>
        </member>
        <member name="M:System.Memory`1.Equals(System.Object)">
            <summary>
            Determines whether the specified object is equal to the current object.
            Returns true if the object is Memory or ReadOnlyMemory and if both objects point to the same array and have the same length.
            </summary>
        </member>
        <member name="M:System.Memory`1.Equals(System.Memory{`0})">
            <summary>
            Returns true if the memory points to the same array and has the same length.  Note that
            this does *not* check to see if the *contents* are equal.
            </summary>
        </member>
        <member name="M:System.Memory`1.GetHashCode">
            <summary>
            Serves as the default hash function.
            </summary>
        </member>
        <member name="T:System.MemoryExtensions">
            <summary>
            Extension methods for Span{T}, Memory{T}, and friends.
            </summary>
            <summary>
            Extension methods for Span{T}, Memory{T}, and friends.
            </summary>
        </member>
        <member name="M:System.MemoryExtensions.Trim(System.ReadOnlySpan{System.Char})">
            <summary>
            Removes all leading and trailing white-space characters from the span.
            </summary>
        </member>
        <member name="M:System.MemoryExtensions.TrimStart(System.ReadOnlySpan{System.Char})">
            <summary>
            Removes all leading white-space characters from the span.
            </summary>
        </member>
        <member name="M:System.MemoryExtensions.TrimEnd(System.ReadOnlySpan{System.Char})">
            <summary>
            Removes all trailing white-space characters from the span.
            </summary>
        </member>
        <member name="M:System.MemoryExtensions.Trim(System.ReadOnlySpan{System.Char},System.Char)">
            <summary>
            Removes all leading and trailing occurrences of a specified character.
            </summary>
            <param name="span">The source span from which the character is removed.</param>
            <param name="trimChar">The specified character to look for and remove.</param>
        </member>
        <member name="M:System.MemoryExtensions.TrimStart(System.ReadOnlySpan{System.Char},System.Char)">
            <summary>
            Removes all leading occurrences of a specified character.
            </summary>
            <param name="span">The source span from which the character is removed.</param>
            <param name="trimChar">The specified character to look for and remove.</param>
        </member>
        <member name="M:System.MemoryExtensions.TrimEnd(System.ReadOnlySpan{System.Char},System.Char)">
            <summary>
            Removes all trailing occurrences of a specified character.
            </summary>
            <param name="span">The source span from which the character is removed.</param>
            <param name="trimChar">The specified character to look for and remove.</param>
        </member>
        <member name="M:System.MemoryExtensions.Trim(System.ReadOnlySpan{System.Char},System.ReadOnlySpan{System.Char})">
            <summary>
            Removes all leading and trailing occurrences of a set of characters specified 
            in a readonly span from the span.
            </summary>
            <param name="span">The source span from which the characters are removed.</param>
            <param name="trimChars">The span which contains the set of characters to remove.</param>
            <remarks>If <paramref name="trimChars"/> is empty, white-space characters are removed instead.</remarks>
        </member>
        <member name="M:System.MemoryExtensions.TrimStart(System.ReadOnlySpan{System.Char},System.ReadOnlySpan{System.Char})">
            <summary>
            Removes all leading occurrences of a set of characters specified 
            in a readonly span from the span.
            </summary>
            <param name="span">The source span from which the characters are removed.</param>
            <param name="trimChars">The span which contains the set of characters to remove.</param>
            <remarks>If <paramref name="trimChars"/> is empty, white-space characters are removed instead.</remarks>
        </member>
        <member name="M:System.MemoryExtensions.TrimEnd(System.ReadOnlySpan{System.Char},System.ReadOnlySpan{System.Char})">
            <summary>
            Removes all trailing occurrences of a set of characters specified 
            in a readonly span from the span.
            </summary>
            <param name="span">The source span from which the characters are removed.</param>
            <param name="trimChars">The span which contains the set of characters to remove.</param>
            <remarks>If <paramref name="trimChars"/> is empty, white-space characters are removed instead.</remarks>
        </member>
        <member name="M:System.MemoryExtensions.IsWhiteSpace(System.ReadOnlySpan{System.Char})">
            <summary>
            Indicates whether the specified span contains only white-space characters.
            </summary>
        </member>
        <member name="M:System.MemoryExtensions.IndexOf``1(System.Span{``0},``0)">
            <summary>
            Searches for the specified value and returns the index of its first occurrence. If not found, returns -1. Values are compared using IEquatable{T}.Equals(T). 
            </summary>
            <param name="span">The span to search.</param>
            <param name="value">The value to search for.</param>
        </member>
        <member name="M:System.MemoryExtensions.IndexOf``1(System.Span{``0},System.ReadOnlySpan{``0})">
            <summary>
            Searches for the specified sequence and returns the index of its first occurrence. If not found, returns -1. Values are compared using IEquatable{T}.Equals(T). 
            </summary>
            <param name="span">The span to search.</param>
            <param name="value">The sequence to search for.</param>
        </member>
        <member name="M:System.MemoryExtensions.LastIndexOf``1(System.Span{``0},``0)">
            <summary>
            Searches for the specified value and returns the index of its last occurrence. If not found, returns -1. Values are compared using IEquatable{T}.Equals(T). 
            </summary>
            <param name="span">The span to search.</param>
            <param name="value">The value to search for.</param>
        </member>
        <member name="M:System.MemoryExtensions.LastIndexOf``1(System.Span{``0},System.ReadOnlySpan{``0})">
            <summary>
            Searches for the specified sequence and returns the index of its last occurrence. If not found, returns -1. Values are compared using IEquatable{T}.Equals(T). 
            </summary>
            <param name="span">The span to search.</param>
            <param name="value">The sequence to search for.</param>
        </member>
        <member name="M:System.MemoryExtensions.SequenceEqual``1(System.Span{``0},System.ReadOnlySpan{``0})">
            <summary>
            Determines whether two sequences are equal by comparing the elements using IEquatable{T}.Equals(T). 
            </summary>
        </member>
        <member name="M:System.MemoryExtensions.SequenceCompareTo``1(System.Span{``0},System.ReadOnlySpan{``0})">
            <summary>
            Determines the relative order of the sequences being compared by comparing the elements using IComparable{T}.CompareTo(T). 
            </summary>
        </member>
        <member name="M:System.MemoryExtensions.IndexOf``1(System.ReadOnlySpan{``0},``0)">
            <summary>
            Searches for the specified value and returns the index of its first occurrence. If not found, returns -1. Values are compared using IEquatable{T}.Equals(T). 
            </summary>
            <param name="span">The span to search.</param>
            <param name="value">The value to search for.</param>
        </member>
        <member name="M:System.MemoryExtensions.IndexOf``1(System.ReadOnlySpan{``0},System.ReadOnlySpan{``0})">
            <summary>
            Searches for the specified sequence and returns the index of its first occurrence. If not found, returns -1. Values are compared using IEquatable{T}.Equals(T). 
            </summary>
            <param name="span">The span to search.</param>
            <param name="value">The sequence to search for.</param>
        </member>
        <member name="M:System.MemoryExtensions.LastIndexOf``1(System.ReadOnlySpan{``0},``0)">
            <summary>
            Searches for the specified value and returns the index of its last occurrence. If not found, returns -1. Values are compared using IEquatable{T}.Equals(T). 
            </summary>
            <param name="span">The span to search.</param>
            <param name="value">The value to search for.</param>
        </member>
        <member name="M:System.MemoryExtensions.LastIndexOf``1(System.ReadOnlySpan{``0},System.ReadOnlySpan{``0})">
            <summary>
            Searches for the specified sequence and returns the index of its last occurrence. If not found, returns -1. Values are compared using IEquatable{T}.Equals(T). 
            </summary>
            <param name="span">The span to search.</param>
            <param name="value">The sequence to search for.</param>
        </member>
        <member name="M:System.MemoryExtensions.IndexOfAny``1(System.Span{``0},``0,``0)">
            <summary>
            Searches for the first index of any of the specified values similar to calling IndexOf several times with the logical OR operator. If not found, returns -1.
            </summary>
            <param name="span">The span to search.</param>
            <param name="value0">One of the values to search for.</param>
            <param name="value1">One of the values to search for.</param>
        </member>
        <member name="M:System.MemoryExtensions.IndexOfAny``1(System.Span{``0},``0,``0,``0)">
            <summary>
            Searches for the first index of any of the specified values similar to calling IndexOf several times with the logical OR operator. If not found, returns -1.
            </summary>
            <param name="span">The span to search.</param>
            <param name="value0">One of the values to search for.</param>
            <param name="value1">One of the values to search for.</param>
            <param name="value2">One of the values to search for.</param>
        </member>
        <member name="M:System.MemoryExtensions.IndexOfAny``1(System.Span{``0},System.ReadOnlySpan{``0})">
            <summary>
            Searches for the first index of any of the specified values similar to calling IndexOf several times with the logical OR operator. If not found, returns -1. 
            </summary>
            <param name="span">The span to search.</param>
            <param name="values">The set of values to search for.</param>
        </member>
        <member name="M:System.MemoryExtensions.IndexOfAny``1(System.ReadOnlySpan{``0},``0,``0)">
            <summary>
            Searches for the first index of any of the specified values similar to calling IndexOf several times with the logical OR operator. If not found, returns -1.
            </summary>
            <param name="span">The span to search.</param>
            <param name="value0">One of the values to search for.</param>
            <param name="value1">One of the values to search for.</param>
        </member>
        <member name="M:System.MemoryExtensions.IndexOfAny``1(System.ReadOnlySpan{``0},``0,``0,``0)">
            <summary>
            Searches for the first index of any of the specified values similar to calling IndexOf several times with the logical OR operator. If not found, returns -1. 
            </summary>
            <param name="span">The span to search.</param>
            <param name="value0">One of the values to search for.</param>
            <param name="value1">One of the values to search for.</param>
            <param name="value2">One of the values to search for.</param>
        </member>
        <member name="M:System.MemoryExtensions.IndexOfAny``1(System.ReadOnlySpan{``0},System.ReadOnlySpan{``0})">
            <summary>
            Searches for the first index of any of the specified values similar to calling IndexOf several times with the logical OR operator. If not found, returns -1. 
            </summary>
            <param name="span">The span to search.</param>
            <param name="values">The set of values to search for.</param>
        </member>
        <member name="M:System.MemoryExtensions.LastIndexOfAny``1(System.Span{``0},``0,``0)">
            <summary>
            Searches for the last index of any of the specified values similar to calling LastIndexOf several times with the logical OR operator. If not found, returns -1.
            </summary>
            <param name="span">The span to search.</param>
            <param name="value0">One of the values to search for.</param>
            <param name="value1">One of the values to search for.</param>
        </member>
        <member name="M:System.MemoryExtensions.LastIndexOfAny``1(System.Span{``0},``0,``0,``0)">
            <summary>
            Searches for the last index of any of the specified values similar to calling LastIndexOf several times with the logical OR operator. If not found, returns -1.
            </summary>
            <param name="span">The span to search.</param>
            <param name="value0">One of the values to search for.</param>
            <param name="value1">One of the values to search for.</param>
            <param name="value2">One of the values to search for.</param>
        </member>
        <member name="M:System.MemoryExtensions.LastIndexOfAny``1(System.Span{``0},System.ReadOnlySpan{``0})">
            <summary>
            Searches for the last index of any of the specified values similar to calling LastIndexOf several times with the logical OR operator. If not found, returns -1. 
            </summary>
            <param name="span">The span to search.</param>
            <param name="values">The set of values to search for.</param>
        </member>
        <member name="M:System.MemoryExtensions.LastIndexOfAny``1(System.ReadOnlySpan{``0},``0,``0)">
            <summary>
            Searches for the last index of any of the specified values similar to calling LastIndexOf several times with the logical OR operator. If not found, returns -1.
            </summary>
            <param name="span">The span to search.</param>
            <param name="value0">One of the values to search for.</param>
            <param name="value1">One of the values to search for.</param>
        </member>
        <member name="M:System.MemoryExtensions.LastIndexOfAny``1(System.ReadOnlySpan{``0},``0,``0,``0)">
            <summary>
            Searches for the last index of any of the specified values similar to calling LastIndexOf several times with the logical OR operator. If not found, returns -1. 
            </summary>
            <param name="span">The span to search.</param>
            <param name="value0">One of the values to search for.</param>
            <param name="value1">One of the values to search for.</param>
            <param name="value2">One of the values to search for.</param>
        </member>
        <member name="M:System.MemoryExtensions.LastIndexOfAny``1(System.ReadOnlySpan{``0},System.ReadOnlySpan{``0})">
            <summary>
            Searches for the last index of any of the specified values similar to calling LastIndexOf several times with the logical OR operator. If not found, returns -1. 
            </summary>
            <param name="span">The span to search.</param>
            <param name="values">The set of values to search for.</param>
        </member>
        <member name="M:System.MemoryExtensions.SequenceEqual``1(System.ReadOnlySpan{``0},System.ReadOnlySpan{``0})">
            <summary>
            Determines whether two sequences are equal by comparing the elements using IEquatable{T}.Equals(T). 
            </summary>
        </member>
        <member name="M:System.MemoryExtensions.SequenceCompareTo``1(System.ReadOnlySpan{``0},System.ReadOnlySpan{``0})">
            <summary>
            Determines the relative order of the sequences being compared by comparing the elements using IComparable{T}.CompareTo(T). 
            </summary>
        </member>
        <member name="M:System.MemoryExtensions.StartsWith``1(System.Span{``0},System.ReadOnlySpan{``0})">
            <summary>
            Determines whether the specified sequence appears at the start of the span.
            </summary>
        </member>
        <member name="M:System.MemoryExtensions.StartsWith``1(System.ReadOnlySpan{``0},System.ReadOnlySpan{``0})">
            <summary>
            Determines whether the specified sequence appears at the start of the span.
            </summary>
        </member>
        <member name="M:System.MemoryExtensions.EndsWith``1(System.Span{``0},System.ReadOnlySpan{``0})">
            <summary>
            Determines whether the specified sequence appears at the end of the span.
            </summary>
        </member>
        <member name="M:System.MemoryExtensions.EndsWith``1(System.ReadOnlySpan{``0},System.ReadOnlySpan{``0})">
            <summary>
            Determines whether the specified sequence appears at the end of the span.
            </summary>
        </member>
        <member name="M:System.MemoryExtensions.Reverse``1(System.Span{``0})">
            <summary>
            Reverses the sequence of the elements in the entire span.
            </summary>
        </member>
        <member name="M:System.MemoryExtensions.AsSpan``1(``0[])">
            <summary>
            Creates a new span over the target array.
            </summary>
        </member>
        <member name="M:System.MemoryExtensions.AsSpan``1(``0[],System.Int32,System.Int32)">
            <summary>
            Creates a new Span over the portion of the target array beginning
            at 'start' index and ending at 'end' index (exclusive).
            </summary>
            <param name="array">The target array.</param>
            <param name="start">The index at which to begin the Span.</param>
            <param name="length">The number of items in the Span.</param>
            <remarks>Returns default when <paramref name="array"/> is null.</remarks>
            <exception cref="T:System.ArrayTypeMismatchException">Thrown when <paramref name="array"/> is covariant and array's type is not exactly T[].</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">
            Thrown when the specified <paramref name="start"/> or end index is not in the range (&lt;0 or &gt;=Length).
            </exception>
        </member>
        <member name="M:System.MemoryExtensions.AsSpan``1(System.ArraySegment{``0})">
            <summary>
            Creates a new span over the portion of the target array segment.
            </summary>
        </member>
        <member name="M:System.MemoryExtensions.AsSpan``1(System.ArraySegment{``0},System.Int32)">
            <summary>
            Creates a new Span over the portion of the target array beginning
            at 'start' index and ending at 'end' index (exclusive).
            </summary>
            <param name="segment">The target array.</param>
            <param name="start">The index at which to begin the Span.</param>
            <remarks>Returns default when <paramref name="segment"/> is null.</remarks>
            <exception cref="T:System.ArrayTypeMismatchException">Thrown when <paramref name="segment"/> is covariant and array's type is not exactly T[].</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">
            Thrown when the specified <paramref name="start"/> or end index is not in the range (&lt;0 or &gt;=segment.Count).
            </exception>
        </member>
        <member name="M:System.MemoryExtensions.AsSpan``1(System.ArraySegment{``0},System.Int32,System.Int32)">
            <summary>
            Creates a new Span over the portion of the target array beginning
            at 'start' index and ending at 'end' index (exclusive).
            </summary>
            <param name="segment">The target array.</param>
            <param name="start">The index at which to begin the Span.</param>
            <param name="length">The number of items in the Span.</param>
            <remarks>Returns default when <paramref name="segment"/> is null.</remarks>
            <exception cref="T:System.ArrayTypeMismatchException">Thrown when <paramref name="segment"/> is covariant and array's type is not exactly T[].</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">
            Thrown when the specified <paramref name="start"/> or end index is not in the range (&lt;0 or &gt;=segment.Count).
            </exception>
        </member>
        <member name="M:System.MemoryExtensions.AsMemory``1(``0[])">
            <summary>
            Creates a new memory over the target array.
            </summary>
        </member>
        <member name="M:System.MemoryExtensions.AsMemory``1(``0[],System.Int32)">
            <summary>
            Creates a new memory over the portion of the target array beginning
            at 'start' index and ending at 'end' index (exclusive).
            </summary>
            <param name="array">The target array.</param>
            <param name="start">The index at which to begin the memory.</param>
            <remarks>Returns default when <paramref name="array"/> is null.</remarks>
            <exception cref="T:System.ArrayTypeMismatchException">Thrown when <paramref name="array"/> is covariant and array's type is not exactly T[].</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">
            Thrown when the specified <paramref name="start"/> or end index is not in the range (&lt;0 or &gt;=array.Length).
            </exception>
        </member>
        <member name="M:System.MemoryExtensions.AsMemory``1(``0[],System.Int32,System.Int32)">
            <summary>
            Creates a new memory over the portion of the target array beginning
            at 'start' index and ending at 'end' index (exclusive).
            </summary>
            <param name="array">The target array.</param>
            <param name="start">The index at which to begin the memory.</param>
            <param name="length">The number of items in the memory.</param>
            <remarks>Returns default when <paramref name="array"/> is null.</remarks>
            <exception cref="T:System.ArrayTypeMismatchException">Thrown when <paramref name="array"/> is covariant and array's type is not exactly T[].</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">
            Thrown when the specified <paramref name="start"/> or end index is not in the range (&lt;0 or &gt;=Length).
            </exception>
        </member>
        <member name="M:System.MemoryExtensions.AsMemory``1(System.ArraySegment{``0})">
            <summary>
            Creates a new memory over the portion of the target array.
            </summary>
        </member>
        <member name="M:System.MemoryExtensions.AsMemory``1(System.ArraySegment{``0},System.Int32)">
            <summary>
            Creates a new memory over the portion of the target array beginning
            at 'start' index and ending at 'end' index (exclusive).
            </summary>
            <param name="segment">The target array.</param>
            <param name="start">The index at which to begin the memory.</param>
            <remarks>Returns default when <paramref name="segment"/> is null.</remarks>
            <exception cref="T:System.ArrayTypeMismatchException">Thrown when <paramref name="segment"/> is covariant and array's type is not exactly T[].</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">
            Thrown when the specified <paramref name="start"/> or end index is not in the range (&lt;0 or &gt;=segment.Count).
            </exception>
        </member>
        <member name="M:System.MemoryExtensions.AsMemory``1(System.ArraySegment{``0},System.Int32,System.Int32)">
            <summary>
            Creates a new memory over the portion of the target array beginning
            at 'start' index and ending at 'end' index (exclusive).
            </summary>
            <param name="segment">The target array.</param>
            <param name="start">The index at which to begin the memory.</param>
            <param name="length">The number of items in the memory.</param>
            <remarks>Returns default when <paramref name="segment"/> is null.</remarks>
            <exception cref="T:System.ArrayTypeMismatchException">Thrown when <paramref name="segment"/> is covariant and array's type is not exactly T[].</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">
            Thrown when the specified <paramref name="start"/> or end index is not in the range (&lt;0 or &gt;=segment.Count).
            </exception>
        </member>
        <member name="M:System.MemoryExtensions.CopyTo``1(``0[],System.Span{``0})">
             <summary>
             Copies the contents of the array into the span. If the source
             and destinations overlap, this method behaves as if the original values in
             a temporary location before the destination is overwritten.
             
            <param name="source">The array to copy items from.</param>
             <param name="destination">The span to copy items into.</param>
             <exception cref="T:System.ArgumentException">
             Thrown when the destination Span is shorter than the source array.
             </exception>
             </summary>
        </member>
        <member name="M:System.MemoryExtensions.CopyTo``1(``0[],System.Memory{``0})">
             <summary>
             Copies the contents of the array into the memory. If the source
             and destinations overlap, this method behaves as if the original values are in
             a temporary location before the destination is overwritten.
             
            <param name="source">The array to copy items from.</param>
             <param name="destination">The memory to copy items into.</param>
             <exception cref="T:System.ArgumentException">
             Thrown when the destination is shorter than the source array.
             </exception>
             </summary>
        </member>
        <member name="M:System.MemoryExtensions.Overlaps``1(System.Span{``0},System.ReadOnlySpan{``0})">
            <summary>
            Determines whether two sequences overlap in memory.
            </summary>
        </member>
        <member name="M:System.MemoryExtensions.Overlaps``1(System.Span{``0},System.ReadOnlySpan{``0},System.Int32@)">
            <summary>
            Determines whether two sequences overlap in memory and outputs the element offset.
            </summary>
        </member>
        <member name="M:System.MemoryExtensions.Overlaps``1(System.ReadOnlySpan{``0},System.ReadOnlySpan{``0})">
            <summary>
            Determines whether two sequences overlap in memory.
            </summary>
        </member>
        <member name="M:System.MemoryExtensions.Overlaps``1(System.ReadOnlySpan{``0},System.ReadOnlySpan{``0},System.Int32@)">
            <summary>
            Determines whether two sequences overlap in memory and outputs the element offset.
            </summary>
        </member>
        <member name="M:System.MemoryExtensions.BinarySearch``1(System.Span{``0},System.IComparable{``0})">
            <summary>
            Searches an entire sorted <see cref="T:System.Span`1"/> for a value
            using the specified <see cref="T:System.IComparable`1"/> generic interface.
            </summary>
            <typeparam name="T">The element type of the span.</typeparam>
            <param name="span">The sorted <see cref="T:System.Span`1"/> to search.</param>
            <param name="comparable">The <see cref="T:System.IComparable`1"/> to use when comparing.</param>
            <returns>
            The zero-based index of <paramref name="comparable"/> in the sorted <paramref name="span"/>,
            if <paramref name="comparable"/> is found; otherwise, a negative number that is the bitwise complement
            of the index of the next element that is larger than <paramref name="comparable"/> or, if there is
            no larger element, the bitwise complement of <see cref="P:System.Span`1.Length"/>.
            </returns>
            <exception cref="T:System.ArgumentNullException">
            <paramref name = "comparable" /> is <see langword="null"/> .
            </exception>
        </member>
        <member name="M:System.MemoryExtensions.BinarySearch``2(System.Span{``0},``1)">
            <summary>
            Searches an entire sorted <see cref="T:System.Span`1"/> for a value
            using the specified <typeparamref name="TComparable"/> generic type.
            </summary>
            <typeparam name="T">The element type of the span.</typeparam>
            <typeparam name="TComparable">The specific type of <see cref="T:System.IComparable`1"/>.</typeparam>
            <param name="span">The sorted <see cref="T:System.Span`1"/> to search.</param>
            <param name="comparable">The <typeparamref name="TComparable"/> to use when comparing.</param>
            <returns>
            The zero-based index of <paramref name="comparable"/> in the sorted <paramref name="span"/>,
            if <paramref name="comparable"/> is found; otherwise, a negative number that is the bitwise complement
            of the index of the next element that is larger than <paramref name="comparable"/> or, if there is
            no larger element, the bitwise complement of <see cref="P:System.Span`1.Length"/>.
            </returns>
            <exception cref="T:System.ArgumentNullException">
            <paramref name = "comparable" /> is <see langword="null"/> .
            </exception>
        </member>
        <member name="M:System.MemoryExtensions.BinarySearch``2(System.Span{``0},``0,``1)">
            <summary>
            Searches an entire sorted <see cref="T:System.Span`1"/> for the specified <paramref name="value"/>
            using the specified <typeparamref name="TComparer"/> generic type.
            </summary>
            <typeparam name="T">The element type of the span.</typeparam>
            <typeparam name="TComparer">The specific type of <see cref="T:System.Collections.Generic.IComparer`1"/>.</typeparam>
            <param name="span">The sorted <see cref="T:System.Span`1"/> to search.</param>
            <param name="value">The object to locate. The value can be null for reference types.</param>
            <param name="comparer">The <typeparamref name="TComparer"/> to use when comparing.</param>
            /// <returns>
            The zero-based index of <paramref name="value"/> in the sorted <paramref name="span"/>,
            if <paramref name="value"/> is found; otherwise, a negative number that is the bitwise complement
            of the index of the next element that is larger than <paramref name="value"/> or, if there is
            no larger element, the bitwise complement of <see cref="P:System.Span`1.Length"/>.
            </returns>
            <exception cref="T:System.ArgumentNullException">
            <paramref name = "comparer" /> is <see langword="null"/> .
            </exception>
        </member>
        <member name="M:System.MemoryExtensions.BinarySearch``1(System.ReadOnlySpan{``0},System.IComparable{``0})">
            <summary>
            Searches an entire sorted <see cref="T:System.ReadOnlySpan`1"/> for a value
            using the specified <see cref="T:System.IComparable`1"/> generic interface.
            </summary>
            <typeparam name="T">The element type of the span.</typeparam>
            <param name="span">The sorted <see cref="T:System.ReadOnlySpan`1"/> to search.</param>
            <param name="comparable">The <see cref="T:System.IComparable`1"/> to use when comparing.</param>
            <returns>
            The zero-based index of <paramref name="comparable"/> in the sorted <paramref name="span"/>,
            if <paramref name="comparable"/> is found; otherwise, a negative number that is the bitwise complement
            of the index of the next element that is larger than <paramref name="comparable"/> or, if there is
            no larger element, the bitwise complement of <see cref="P:System.ReadOnlySpan`1.Length"/>.
            </returns>
            <exception cref="T:System.ArgumentNullException">
            <paramref name = "comparable" /> is <see langword="null"/> .
            </exception>
        </member>
        <member name="M:System.MemoryExtensions.BinarySearch``2(System.ReadOnlySpan{``0},``1)">
            <summary>
            Searches an entire sorted <see cref="T:System.ReadOnlySpan`1"/> for a value
            using the specified <typeparamref name="TComparable"/> generic type.
            </summary>
            <typeparam name="T">The element type of the span.</typeparam>
            <typeparam name="TComparable">The specific type of <see cref="T:System.IComparable`1"/>.</typeparam>
            <param name="span">The sorted <see cref="T:System.ReadOnlySpan`1"/> to search.</param>
            <param name="comparable">The <typeparamref name="TComparable"/> to use when comparing.</param>
            <returns>
            The zero-based index of <paramref name="comparable"/> in the sorted <paramref name="span"/>,
            if <paramref name="comparable"/> is found; otherwise, a negative number that is the bitwise complement
            of the index of the next element that is larger than <paramref name="comparable"/> or, if there is
            no larger element, the bitwise complement of <see cref="P:System.ReadOnlySpan`1.Length"/>.
            </returns>
            <exception cref="T:System.ArgumentNullException">
            <paramref name = "comparable" /> is <see langword="null"/> .
            </exception>
        </member>
        <member name="M:System.MemoryExtensions.BinarySearch``2(System.ReadOnlySpan{``0},``0,``1)">
            <summary>
            Searches an entire sorted <see cref="T:System.ReadOnlySpan`1"/> for the specified <paramref name="value"/>
            using the specified <typeparamref name="TComparer"/> generic type.
            </summary>
            <typeparam name="T">The element type of the span.</typeparam>
            <typeparam name="TComparer">The specific type of <see cref="T:System.Collections.Generic.IComparer`1"/>.</typeparam>
            <param name="span">The sorted <see cref="T:System.ReadOnlySpan`1"/> to search.</param>
            <param name="value">The object to locate. The value can be null for reference types.</param>
            <param name="comparer">The <typeparamref name="TComparer"/> to use when comparing.</param>
            /// <returns>
            The zero-based index of <paramref name="value"/> in the sorted <paramref name="span"/>,
            if <paramref name="value"/> is found; otherwise, a negative number that is the bitwise complement
            of the index of the next element that is larger than <paramref name="value"/> or, if there is
            no larger element, the bitwise complement of <see cref="P:System.ReadOnlySpan`1.Length"/>.
            </returns>
            <exception cref="T:System.ArgumentNullException">
            <paramref name = "comparer" /> is <see langword="null"/> .
            </exception>
        </member>
        <member name="M:System.MemoryExtensions.AsSpan``1(``0[],System.Int32)">
            <summary>
            Creates a new span over the portion of the target array.
            </summary>
        </member>
        <member name="M:System.MemoryExtensions.Contains(System.ReadOnlySpan{System.Char},System.ReadOnlySpan{System.Char},System.StringComparison)">
            <summary>
            Returns a value indicating whether the specified <paramref name="value"/> occurs within the <paramref name="span"/>.
            <param name="span">The source span.</param>
            <param name="value">The value to seek within the source span.</param>
            <param name="comparisonType">One of the enumeration values that determines how the <paramref name="span"/> and <paramref name="value"/> are compared.</param>
            </summary>
        </member>
        <member name="M:System.MemoryExtensions.Equals(System.ReadOnlySpan{System.Char},System.ReadOnlySpan{System.Char},System.StringComparison)">
            <summary>
            Determines whether this <paramref name="span"/> and the specified <paramref name="other"/> span have the same characters
            when compared using the specified <paramref name="comparisonType"/> option.
            <param name="span">The source span.</param>
            <param name="other">The value to compare with the source span.</param>
            <param name="comparisonType">One of the enumeration values that determines how the <paramref name="span"/> and <paramref name="other"/> are compared.</param>
            </summary>
        </member>
        <member name="M:System.MemoryExtensions.CompareTo(System.ReadOnlySpan{System.Char},System.ReadOnlySpan{System.Char},System.StringComparison)">
            <summary>
            Compares the specified <paramref name="span"/> and <paramref name="other"/> using the specified <paramref name="comparisonType"/>,
            and returns an integer that indicates their relative position in the sort order.
            <param name="span">The source span.</param>
            <param name="other">The value to compare with the source span.</param>
            <param name="comparisonType">One of the enumeration values that determines how the <paramref name="span"/> and <paramref name="other"/> are compared.</param>
            </summary>
        </member>
        <member name="M:System.MemoryExtensions.IndexOf(System.ReadOnlySpan{System.Char},System.ReadOnlySpan{System.Char},System.StringComparison)">
            <summary>
            Reports the zero-based index of the first occurrence of the specified <paramref name="value"/> in the current <paramref name="span"/>.
            <param name="span">The source span.</param>
            <param name="value">The value to seek within the source span.</param>
            <param name="comparisonType">One of the enumeration values that determines how the <paramref name="span"/> and <paramref name="value"/> are compared.</param>
            </summary>
        </member>
        <member name="M:System.MemoryExtensions.ToLower(System.ReadOnlySpan{System.Char},System.Span{System.Char},System.Globalization.CultureInfo)">
            <summary>
            Copies the characters from the source span into the destination, converting each character to lowercase,
            using the casing rules of the specified culture.
            </summary>
            <param name="source">The source span.</param>
            <param name="destination">The destination span which contains the transformed characters.</param>
            <param name="culture">An object that supplies culture-specific casing rules.</param>
            <remarks>If the source and destinations overlap, this method behaves as if the original values are in
            a temporary location before the destination is overwritten.</remarks>
            <exception cref="T:System.ArgumentNullException">
            Thrown when <paramref name="culture"/> is null.
            </exception>
        </member>
        <member name="M:System.MemoryExtensions.ToLowerInvariant(System.ReadOnlySpan{System.Char},System.Span{System.Char})">
            <summary>
            Copies the characters from the source span into the destination, converting each character to lowercase,
            using the casing rules of the invariant culture.
            </summary>
            <param name="source">The source span.</param>
            <param name="destination">The destination span which contains the transformed characters.</param>
            <remarks>If the source and destinations overlap, this method behaves as if the original values are in
            a temporary location before the destination is overwritten.</remarks>
        </member>
        <member name="M:System.MemoryExtensions.ToUpper(System.ReadOnlySpan{System.Char},System.Span{System.Char},System.Globalization.CultureInfo)">
            <summary>
            Copies the characters from the source span into the destination, converting each character to uppercase,
            using the casing rules of the specified culture.
            </summary>
            <param name="source">The source span.</param>
            <param name="destination">The destination span which contains the transformed characters.</param>
            <param name="culture">An object that supplies culture-specific casing rules.</param>
            <remarks>If the source and destinations overlap, this method behaves as if the original values are in
            a temporary location before the destination is overwritten.</remarks>
            <exception cref="T:System.ArgumentNullException">
            Thrown when <paramref name="culture"/> is null.
            </exception>
        </member>
        <member name="M:System.MemoryExtensions.ToUpperInvariant(System.ReadOnlySpan{System.Char},System.Span{System.Char})">
            <summary>
            Copies the characters from the source span into the destination, converting each character to uppercase
            using the casing rules of the invariant culture.
            </summary>
            <param name="source">The source span.</param>
            <param name="destination">The destination span which contains the transformed characters.</param>
            <remarks>If the source and destinations overlap, this method behaves as if the original values are in
            a temporary location before the destination is overwritten.</remarks>
        </member>
        <member name="M:System.MemoryExtensions.EndsWith(System.ReadOnlySpan{System.Char},System.ReadOnlySpan{System.Char},System.StringComparison)">
            <summary>
            Determines whether the end of the <paramref name="span"/> matches the specified <paramref name="value"/> when compared using the specified <paramref name="comparisonType"/> option.
            </summary>
            <param name="span">The source span.</param>
            <param name="value">The sequence to compare to the end of the source span.</param>
            <param name="comparisonType">One of the enumeration values that determines how the <paramref name="span"/> and <paramref name="value"/> are compared.</param>
        </member>
        <member name="M:System.MemoryExtensions.StartsWith(System.ReadOnlySpan{System.Char},System.ReadOnlySpan{System.Char},System.StringComparison)">
            <summary>
            Determines whether the beginning of the <paramref name="span"/> matches the specified <paramref name="value"/> when compared using the specified <paramref name="comparisonType"/> option.
            </summary>
            <param name="span">The source span.</param>
            <param name="value">The sequence to compare to the beginning of the source span.</param>
            <param name="comparisonType">One of the enumeration values that determines how the <paramref name="span"/> and <paramref name="value"/> are compared.</param>
        </member>
        <member name="M:System.MemoryExtensions.AsSpan(System.String)">
            <summary>
            Creates a new readonly span over the portion of the target string.
            </summary>
            <param name="text">The target string.</param>
            <remarks>Returns default when <paramref name="text"/> is null.</remarks>
        </member>
        <member name="M:System.MemoryExtensions.AsSpan(System.String,System.Int32)">
            <summary>
            Creates a new readonly span over the portion of the target string.
            </summary>
            <param name="text">The target string.</param>
            <param name="start">The index at which to begin this slice.</param>
            <remarks>Returns default when <paramref name="text"/> is null.</remarks>
            <exception cref="T:System.ArgumentOutOfRangeException">
            Thrown when the specified <paramref name="start"/> index is not in range (&lt;0 or &gt;text.Length).
            </exception>
        </member>
        <member name="M:System.MemoryExtensions.AsSpan(System.String,System.Int32,System.Int32)">
            <summary>
            Creates a new readonly span over the portion of the target string.
            </summary>
            <param name="text">The target string.</param>
            <param name="start">The index at which to begin this slice.</param>
            <param name="length">The desired length for the slice (exclusive).</param>
            <remarks>Returns default when <paramref name="text"/> is null.</remarks>
            <exception cref="T:System.ArgumentOutOfRangeException">
            Thrown when the specified <paramref name="start"/> index or <paramref name="length"/> is not in range.
            </exception>
        </member>
        <member name="M:System.MemoryExtensions.AsMemory(System.String)">
            <summary>Creates a new <see cref="T:System.ReadOnlyMemory`1"/> over the portion of the target string.</summary>
            <param name="text">The target string.</param>
            <remarks>Returns default when <paramref name="text"/> is null.</remarks>
        </member>
        <member name="M:System.MemoryExtensions.AsMemory(System.String,System.Int32)">
            <summary>Creates a new <see cref="T:System.ReadOnlyMemory`1"/> over the portion of the target string.</summary>
            <param name="text">The target string.</param>
            <param name="start">The index at which to begin this slice.</param>
            <remarks>Returns default when <paramref name="text"/> is null.</remarks>
            <exception cref="T:System.ArgumentOutOfRangeException">
            Thrown when the specified <paramref name="start"/> index is not in range (&lt;0 or &gt;text.Length).
            </exception>
        </member>
        <member name="M:System.MemoryExtensions.AsMemory(System.String,System.Int32,System.Int32)">
            <summary>Creates a new <see cref="T:System.ReadOnlyMemory`1"/> over the portion of the target string.</summary>
            <param name="text">The target string.</param>
            <param name="start">The index at which to begin this slice.</param>
            <param name="length">The desired length for the slice (exclusive).</param>
            <remarks>Returns default when <paramref name="text"/> is null.</remarks>
            <exception cref="T:System.ArgumentOutOfRangeException">
            Thrown when the specified <paramref name="start"/> index or <paramref name="length"/> is not in range.
            </exception>
        </member>
        <member name="T:System.ReadOnlyMemory`1">
            <summary>
            Represents a contiguous region of memory, similar to <see cref="T:System.ReadOnlySpan`1"/>.
            Unlike <see cref="T:System.ReadOnlySpan`1"/>, it is not a byref-like type.
            </summary>
        </member>
        <member name="M:System.ReadOnlyMemory`1.#ctor(`0[])">
            <summary>
            Creates a new memory over the entirety of the target array.
            </summary>
            <param name="array">The target array.</param>
            <remarks>Returns default when <paramref name="array"/> is null.</remarks>
            <exception cref="T:System.ArrayTypeMismatchException">Thrown when <paramref name="array"/> is covariant and array's type is not exactly T[].</exception>
        </member>
        <member name="M:System.ReadOnlyMemory`1.#ctor(`0[],System.Int32,System.Int32)">
            <summary>
            Creates a new memory over the portion of the target array beginning
            at 'start' index and ending at 'end' index (exclusive).
            </summary>
            <param name="array">The target array.</param>
            <param name="start">The index at which to begin the memory.</param>
            <param name="length">The number of items in the memory.</param>
            <remarks>Returns default when <paramref name="array"/> is null.</remarks>
            <exception cref="T:System.ArrayTypeMismatchException">Thrown when <paramref name="array"/> is covariant and array's type is not exactly T[].</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">
            Thrown when the specified <paramref name="start"/> or end index is not in the range (&lt;0 or &gt;=Length).
            </exception>
        </member>
        <member name="M:System.ReadOnlyMemory`1.#ctor(System.Object,System.Int32,System.Int32)">
            <summary>Creates a new memory over the existing object, start, and length. No validation is performed.</summary>
            <param name="obj">The target object.</param>
            <param name="start">The index at which to begin the memory.</param>
            <param name="length">The number of items in the memory.</param>
        </member>
        <member name="M:System.ReadOnlyMemory`1.op_Implicit(`0[])~System.ReadOnlyMemory{`0}">
            <summary>
            Defines an implicit conversion of an array to a <see cref="T:System.ReadOnlyMemory`1"/>
            </summary>
        </member>
        <member name="M:System.ReadOnlyMemory`1.op_Implicit(System.ArraySegment{`0})~System.ReadOnlyMemory{`0}">
            <summary>
            Defines an implicit conversion of a <see cref="T:System.ArraySegment`1"/> to a <see cref="T:System.ReadOnlyMemory`1"/>
            </summary>
        </member>
        <member name="P:System.ReadOnlyMemory`1.Empty">
            <summary>
            Returns an empty <see cref="T:System.ReadOnlyMemory`1"/>
            </summary>
        </member>
        <member name="P:System.ReadOnlyMemory`1.Length">
            <summary>
            The number of items in the memory.
            </summary>
        </member>
        <member name="P:System.ReadOnlyMemory`1.IsEmpty">
            <summary>
            Returns true if Length is 0.
            </summary>
        </member>
        <member name="M:System.ReadOnlyMemory`1.ToString">
            <summary>
            For <see cref="T:System.ReadOnlyMemory`1"/>, returns a new instance of string that represents the characters pointed to by the memory.
            Otherwise, returns a <see cref="T:System.String"/> with the name of the type and the number of elements.
            </summary>
        </member>
        <member name="M:System.ReadOnlyMemory`1.Slice(System.Int32)">
            <summary>
            Forms a slice out of the given memory, beginning at 'start'.
            </summary>
            <param name="start">The index at which to begin this slice.</param>
            <exception cref="T:System.ArgumentOutOfRangeException">
            Thrown when the specified <paramref name="start"/> index is not in range (&lt;0 or &gt;=Length).
            </exception>
        </member>
        <member name="M:System.ReadOnlyMemory`1.Slice(System.Int32,System.Int32)">
            <summary>
            Forms a slice out of the given memory, beginning at 'start', of given length
            </summary>
            <param name="start">The index at which to begin this slice.</param>
            <param name="length">The desired length for the slice (exclusive).</param>
            <exception cref="T:System.ArgumentOutOfRangeException">
            Thrown when the specified <paramref name="start"/> or end index is not in range (&lt;0 or &gt;=Length).
            </exception>
        </member>
        <member name="P:System.ReadOnlyMemory`1.Span">
            <summary>
            Returns a span from the memory.
            </summary>
        </member>
        <member name="M:System.ReadOnlyMemory`1.CopyTo(System.Memory{`0})">
             <summary>
             Copies the contents of the read-only memory into the destination. If the source
             and destination overlap, this method behaves as if the original values are in
             a temporary location before the destination is overwritten.
            
             <param name="destination">The Memory to copy items into.</param>
             <exception cref="T:System.ArgumentException">
             Thrown when the destination is shorter than the source.
             </exception>
             </summary>
        </member>
        <member name="M:System.ReadOnlyMemory`1.TryCopyTo(System.Memory{`0})">
             <summary>
             Copies the contents of the readonly-only memory into the destination. If the source
             and destination overlap, this method behaves as if the original values are in
             a temporary location before the destination is overwritten.
            
             <returns>If the destination is shorter than the source, this method
             return false and no data is written to the destination.</returns>
             </summary>
             <param name="destination">The span to copy items into.</param>
        </member>
        <member name="M:System.ReadOnlyMemory`1.Pin">
            <summary>
            Creates a handle for the memory.
            The GC will not move the memory until the returned <see cref="T:System.Buffers.MemoryHandle"/>
            is disposed, enabling taking and using the memory's address.
            <exception cref="T:System.ArgumentException">
            An instance with nonprimitive (non-blittable) members cannot be pinned.
            </exception>
            </summary>
        </member>
        <member name="M:System.ReadOnlyMemory`1.ToArray">
            <summary>
            Copies the contents from the memory into a new array.  This heap
            allocates, so should generally be avoided, however it is sometimes
            necessary to bridge the gap with APIs written in terms of arrays.
            </summary>
        </member>
        <member name="M:System.ReadOnlyMemory`1.Equals(System.Object)">
            <summary>Determines whether the specified object is equal to the current object.</summary>
        </member>
        <member name="M:System.ReadOnlyMemory`1.Equals(System.ReadOnlyMemory{`0})">
            <summary>
            Returns true if the memory points to the same array and has the same length.  Note that
            this does *not* check to see if the *contents* are equal.
            </summary>
        </member>
        <member name="M:System.ReadOnlyMemory`1.GetHashCode">
            <summary>Returns the hash code for this <see cref="T:System.ReadOnlyMemory`1"/></summary>
        </member>
        <member name="M:System.ReadOnlyMemory`1.GetObjectStartLength(System.Int32@,System.Int32@)">
            <summary>Gets the state of the memory as individual fields.</summary>
            <param name="start">The offset.</param>
            <param name="length">The count.</param>
            <returns>The object.</returns>
        </member>
        <member name="T:System.ReadOnlySpan`1">
            <summary>
            ReadOnlySpan represents a contiguous region of arbitrary memory. Unlike arrays, it can point to either managed
            or native memory, or to memory allocated on the stack. It is type- and memory-safe.
            </summary>
            <summary>
            ReadOnlySpan represents a contiguous region of arbitrary memory. Unlike arrays, it can point to either managed
            or native memory, or to memory allocated on the stack. It is type- and memory-safe.
            </summary>
        </member>
        <member name="P:System.ReadOnlySpan`1.Length">
            <summary>
            The number of items in the read-only span.
            </summary>
        </member>
        <member name="P:System.ReadOnlySpan`1.IsEmpty">
            <summary>
            Returns true if Length is 0.
            </summary>
        </member>
        <member name="M:System.ReadOnlySpan`1.op_Inequality(System.ReadOnlySpan{`0},System.ReadOnlySpan{`0})">
            <summary>
            Returns false if left and right point at the same memory and have the same length.  Note that
            this does *not* check to see if the *contents* are equal.
            </summary>
        </member>
        <member name="M:System.ReadOnlySpan`1.Equals(System.Object)">
            <summary>
            This method is not supported as spans cannot be boxed. To compare two spans, use operator==.
            <exception cref="T:System.NotSupportedException">
            Always thrown by this method.
            </exception>
            </summary>
        </member>
        <member name="M:System.ReadOnlySpan`1.GetHashCode">
            <summary>
            This method is not supported as spans cannot be boxed.
            <exception cref="T:System.NotSupportedException">
            Always thrown by this method.
            </exception>
            </summary>
        </member>
        <member name="M:System.ReadOnlySpan`1.op_Implicit(`0[])~System.ReadOnlySpan{`0}">
            <summary>
            Defines an implicit conversion of an array to a <see cref="T:System.ReadOnlySpan`1"/>
            </summary>
        </member>
        <member name="M:System.ReadOnlySpan`1.op_Implicit(System.ArraySegment{`0})~System.ReadOnlySpan{`0}">
            <summary>
            Defines an implicit conversion of a <see cref="T:System.ArraySegment`1"/> to a <see cref="T:System.ReadOnlySpan`1"/>
            </summary>
        </member>
        <member name="P:System.ReadOnlySpan`1.Empty">
            <summary>
            Returns a 0-length read-only span whose base is the null pointer.
            </summary>
        </member>
        <member name="M:System.ReadOnlySpan`1.GetEnumerator">
            <summary>Gets an enumerator for this span.</summary>
        </member>
        <member name="T:System.ReadOnlySpan`1.Enumerator">
            <summary>Enumerates the elements of a <see cref="T:System.ReadOnlySpan`1"/>.</summary>
        </member>
        <member name="F:System.ReadOnlySpan`1.Enumerator._span">
            <summary>The span being enumerated.</summary>
        </member>
        <member name="F:System.ReadOnlySpan`1.Enumerator._index">
            <summary>The next index to yield.</summary>
        </member>
        <member name="M:System.ReadOnlySpan`1.Enumerator.#ctor(System.ReadOnlySpan{`0})">
            <summary>Initialize the enumerator.</summary>
            <param name="span">The span to enumerate.</param>
        </member>
        <member name="M:System.ReadOnlySpan`1.Enumerator.MoveNext">
            <summary>Advances the enumerator to the next element of the span.</summary>
        </member>
        <member name="P:System.ReadOnlySpan`1.Enumerator.Current">
            <summary>Gets the element at the current position of the enumerator.</summary>
        </member>
        <member name="M:System.ReadOnlySpan`1.#ctor(`0[])">
            <summary>
            Creates a new read-only span over the entirety of the target array.
            </summary>
            <param name="array">The target array.</param>
            <remarks>Returns default when <paramref name="array"/> is null.</remarks>
            <exception cref="T:System.ArrayTypeMismatchException">Thrown when <paramref name="array"/> is covariant and array's type is not exactly T[].</exception>
        </member>
        <member name="M:System.ReadOnlySpan`1.#ctor(`0[],System.Int32,System.Int32)">
            <summary>
            Creates a new read-only span over the portion of the target array beginning
            at 'start' index and ending at 'end' index (exclusive).
            </summary>
            <param name="array">The target array.</param>
            <param name="start">The index at which to begin the read-only span.</param>
            <param name="length">The number of items in the read-only span.</param>
            <remarks>Returns default when <paramref name="array"/> is null.</remarks>
            <exception cref="T:System.ArrayTypeMismatchException">Thrown when <paramref name="array"/> is covariant and array's type is not exactly T[].</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">
            Thrown when the specified <paramref name="start"/> or end index is not in the range (&lt;0 or &gt;=Length).
            </exception>
        </member>
        <member name="M:System.ReadOnlySpan`1.#ctor(System.Void*,System.Int32)">
            <summary>
            Creates a new read-only span over the target unmanaged buffer.  Clearly this
            is quite dangerous, because we are creating arbitrarily typed T's
            out of a void*-typed block of memory.  And the length is not checked.
            But if this creation is correct, then all subsequent uses are correct.
            </summary>
            <param name="pointer">An unmanaged pointer to memory.</param>
            <param name="length">The number of <typeparamref name="T"/> elements the memory contains.</param>
            <exception cref="T:System.ArgumentException">
            Thrown when <typeparamref name="T"/> is reference type or contains pointers and hence cannot be stored in unmanaged memory.
            </exception>
            <exception cref="T:System.ArgumentOutOfRangeException">
            Thrown when the specified <paramref name="length"/> is negative.
            </exception>
        </member>
        <member name="P:System.ReadOnlySpan`1.Item(System.Int32)">
            <summary>
            Returns the specified element of the read-only span.
            </summary>
            <param name="index"></param>
            <returns></returns>
            <exception cref="T:System.IndexOutOfRangeException">
            Thrown when index less than 0 or index greater than or equal to Length
            </exception>
        </member>
        <member name="M:System.ReadOnlySpan`1.GetPinnableReference">
            <summary>
            Returns a reference to the 0th element of the Span. If the Span is empty, returns null reference.
            It can be used for pinning and is required to support the use of span within a fixed statement.
            </summary>
        </member>
        <member name="M:System.ReadOnlySpan`1.CopyTo(System.Span{`0})">
            <summary>
            Copies the contents of this read-only span into destination span. If the source
            and destinations overlap, this method behaves as if the original values in
            a temporary location before the destination is overwritten.
            </summary>
            <param name="destination">The span to copy items into.</param>
            <exception cref="T:System.ArgumentException">
            Thrown when the destination Span is shorter than the source Span.
            </exception>
        </member>
        <member name="M:System.ReadOnlySpan`1.TryCopyTo(System.Span{`0})">
            <summary>
            Copies the contents of this read-only span into destination span. If the source
            and destinations overlap, this method behaves as if the original values in
            a temporary location before the destination is overwritten.
            </summary>
            <returns>If the destination span is shorter than the source span, this method
            return false and no data is written to the destination.</returns>
            <param name="destination">The span to copy items into.</param>
        </member>
        <member name="M:System.ReadOnlySpan`1.op_Equality(System.ReadOnlySpan{`0},System.ReadOnlySpan{`0})">
            <summary>
            Returns true if left and right point at the same memory and have the same length.  Note that
            this does *not* check to see if the *contents* are equal.
            </summary>
        </member>
        <member name="M:System.ReadOnlySpan`1.ToString">
            <summary>
            For <see cref="T:System.Span`1"/>, returns a new instance of string that represents the characters pointed to by the span.
            Otherwise, returns a <see cref="T:System.String"/> with the name of the type and the number of elements.
            </summary>
        </member>
        <member name="M:System.ReadOnlySpan`1.Slice(System.Int32)">
            <summary>
            Forms a slice out of the given read-only span, beginning at 'start'.
            </summary>
            <param name="start">The index at which to begin this slice.</param>
            <exception cref="T:System.ArgumentOutOfRangeException">
            Thrown when the specified <paramref name="start"/> index is not in range (&lt;0 or &gt;=Length).
            </exception>
        </member>
        <member name="M:System.ReadOnlySpan`1.Slice(System.Int32,System.Int32)">
            <summary>
            Forms a slice out of the given read-only span, beginning at 'start', of given length
            </summary>
            <param name="start">The index at which to begin this slice.</param>
            <param name="length">The desired length for the slice (exclusive).</param>
            <exception cref="T:System.ArgumentOutOfRangeException">
            Thrown when the specified <paramref name="start"/> or end index is not in range (&lt;0 or &gt;=Length).
            </exception>
        </member>
        <member name="M:System.ReadOnlySpan`1.ToArray">
            <summary>
            Copies the contents of this read-only span into a new array.  This heap
            allocates, so should generally be avoided, however it is sometimes
            necessary to bridge the gap with APIs written in terms of arrays.
            </summary>
        </member>
        <member name="M:System.ReadOnlySpan`1.DangerousGetPinnableReference">
            <summary>
            Returns a reference to the 0th element of the Span. If the Span is empty, returns a reference to the location where the 0th element
            would have been stored. Such a reference can be used for pinning but must never be dereferenced.
            </summary>
        </member>
        <member name="T:System.Span`1">
            <summary>
            Span represents a contiguous region of arbitrary memory. Unlike arrays, it can point to either managed
            or native memory, or to memory allocated on the stack. It is type- and memory-safe.
            </summary>
            <summary>
            Span represents a contiguous region of arbitrary memory. Unlike arrays, it can point to either managed
            or native memory, or to memory allocated on the stack. It is type- and memory-safe.
            </summary>
        </member>
        <member name="P:System.Span`1.Length">
            <summary>
            The number of items in the span.
            </summary>
        </member>
        <member name="P:System.Span`1.IsEmpty">
            <summary>
            Returns true if Length is 0.
            </summary>
        </member>
        <member name="M:System.Span`1.op_Inequality(System.Span{`0},System.Span{`0})">
            <summary>
            Returns false if left and right point at the same memory and have the same length.  Note that
            this does *not* check to see if the *contents* are equal.
            </summary>
        </member>
        <member name="M:System.Span`1.Equals(System.Object)">
            <summary>
            This method is not supported as spans cannot be boxed. To compare two spans, use operator==.
            <exception cref="T:System.NotSupportedException">
            Always thrown by this method.
            </exception>
            </summary>
        </member>
        <member name="M:System.Span`1.GetHashCode">
            <summary>
            This method is not supported as spans cannot be boxed.
            <exception cref="T:System.NotSupportedException">
            Always thrown by this method.
            </exception>
            </summary>
        </member>
        <member name="M:System.Span`1.op_Implicit(`0[])~System.Span{`0}">
            <summary>
            Defines an implicit conversion of an array to a <see cref="T:System.Span`1"/>
            </summary>
        </member>
        <member name="M:System.Span`1.op_Implicit(System.ArraySegment{`0})~System.Span{`0}">
            <summary>
            Defines an implicit conversion of a <see cref="T:System.ArraySegment`1"/> to a <see cref="T:System.Span`1"/>
            </summary>
        </member>
        <member name="P:System.Span`1.Empty">
            <summary>
            Returns an empty <see cref="T:System.Span`1"/>
            </summary>
        </member>
        <member name="M:System.Span`1.GetEnumerator">
            <summary>Gets an enumerator for this span.</summary>
        </member>
        <member name="T:System.Span`1.Enumerator">
            <summary>Enumerates the elements of a <see cref="T:System.Span`1"/>.</summary>
        </member>
        <member name="F:System.Span`1.Enumerator._span">
            <summary>The span being enumerated.</summary>
        </member>
        <member name="F:System.Span`1.Enumerator._index">
            <summary>The next index to yield.</summary>
        </member>
        <member name="M:System.Span`1.Enumerator.#ctor(System.Span{`0})">
            <summary>Initialize the enumerator.</summary>
            <param name="span">The span to enumerate.</param>
        </member>
        <member name="M:System.Span`1.Enumerator.MoveNext">
            <summary>Advances the enumerator to the next element of the span.</summary>
        </member>
        <member name="P:System.Span`1.Enumerator.Current">
            <summary>Gets the element at the current position of the enumerator.</summary>
        </member>
        <member name="M:System.Span`1.#ctor(`0[])">
            <summary>
            Creates a new span over the entirety of the target array.
            </summary>
            <param name="array">The target array.</param>
            <remarks>Returns default when <paramref name="array"/> is null.</remarks>
            <exception cref="T:System.ArrayTypeMismatchException">Thrown when <paramref name="array"/> is covariant and array's type is not exactly T[].</exception>
        </member>
        <member name="M:System.Span`1.#ctor(`0[],System.Int32,System.Int32)">
            <summary>
            Creates a new span over the portion of the target array beginning
            at 'start' index and ending at 'end' index (exclusive).
            </summary>
            <param name="array">The target array.</param>
            <param name="start">The index at which to begin the span.</param>
            <param name="length">The number of items in the span.</param>
            <remarks>Returns default when <paramref name="array"/> is null.</remarks>
            <exception cref="T:System.ArrayTypeMismatchException">Thrown when <paramref name="array"/> is covariant and array's type is not exactly T[].</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">
            Thrown when the specified <paramref name="start"/> or end index is not in the range (&lt;0 or &gt;=Length).
            </exception>
        </member>
        <member name="M:System.Span`1.#ctor(System.Void*,System.Int32)">
            <summary>
            Creates a new span over the target unmanaged buffer.  Clearly this
            is quite dangerous, because we are creating arbitrarily typed T's
            out of a void*-typed block of memory.  And the length is not checked.
            But if this creation is correct, then all subsequent uses are correct.
            </summary>
            <param name="pointer">An unmanaged pointer to memory.</param>
            <param name="length">The number of <typeparamref name="T"/> elements the memory contains.</param>
            <exception cref="T:System.ArgumentException">
            Thrown when <typeparamref name="T"/> is reference type or contains pointers and hence cannot be stored in unmanaged memory.
            </exception>
            <exception cref="T:System.ArgumentOutOfRangeException">
            Thrown when the specified <paramref name="length"/> is negative.
            </exception>
        </member>
        <member name="P:System.Span`1.Item(System.Int32)">
            <summary>
            Returns a reference to specified element of the Span.
            </summary>
            <param name="index"></param>
            <returns></returns>
            <exception cref="T:System.IndexOutOfRangeException">
            Thrown when index less than 0 or index greater than or equal to Length
            </exception>
        </member>
        <member name="M:System.Span`1.GetPinnableReference">
            <summary>
            Returns a reference to the 0th element of the Span. If the Span is empty, returns null reference.
            It can be used for pinning and is required to support the use of span within a fixed statement.
            </summary>
        </member>
        <member name="M:System.Span`1.Clear">
            <summary>
            Clears the contents of this span.
            </summary>
        </member>
        <member name="M:System.Span`1.Fill(`0)">
            <summary>
            Fills the contents of this span with the given value.
            </summary>
        </member>
        <member name="M:System.Span`1.CopyTo(System.Span{`0})">
             <summary>
             Copies the contents of this span into destination span. If the source
             and destinations overlap, this method behaves as if the original values in
             a temporary location before the destination is overwritten.
            
             <param name="destination">The span to copy items into.</param>
             <exception cref="T:System.ArgumentException">
             Thrown when the destination Span is shorter than the source Span.
             </exception>
             </summary>
        </member>
        <member name="M:System.Span`1.TryCopyTo(System.Span{`0})">
             <summary>
             Copies the contents of this span into destination span. If the source
             and destinations overlap, this method behaves as if the original values in
             a temporary location before the destination is overwritten.
            
             <returns>If the destination span is shorter than the source span, this method
             return false and no data is written to the destination.</returns>
             </summary>
             <param name="destination">The span to copy items into.</param>
        </member>
        <member name="M:System.Span`1.op_Equality(System.Span{`0},System.Span{`0})">
            <summary>
            Returns true if left and right point at the same memory and have the same length.  Note that
            this does *not* check to see if the *contents* are equal.
            </summary>
        </member>
        <member name="M:System.Span`1.op_Implicit(System.Span{`0})~System.ReadOnlySpan{`0}">
            <summary>
            Defines an implicit conversion of a <see cref="T:System.Span`1"/> to a <see cref="T:System.ReadOnlySpan`1"/>
            </summary>
        </member>
        <member name="M:System.Span`1.ToString">
            <summary>
            For <see cref="T:System.Span`1"/>, returns a new instance of string that represents the characters pointed to by the span.
            Otherwise, returns a <see cref="T:System.String"/> with the name of the type and the number of elements.
            </summary>
        </member>
        <member name="M:System.Span`1.Slice(System.Int32)">
            <summary>
            Forms a slice out of the given span, beginning at 'start'.
            </summary>
            <param name="start">The index at which to begin this slice.</param>
            <exception cref="T:System.ArgumentOutOfRangeException">
            Thrown when the specified <paramref name="start"/> index is not in range (&lt;0 or &gt;=Length).
            </exception>
        </member>
        <member name="M:System.Span`1.Slice(System.Int32,System.Int32)">
            <summary>
            Forms a slice out of the given span, beginning at 'start', of given length
            </summary>
            <param name="start">The index at which to begin this slice.</param>
            <param name="length">The desired length for the slice (exclusive).</param>
            <exception cref="T:System.ArgumentOutOfRangeException">
            Thrown when the specified <paramref name="start"/> or end index is not in range (&lt;0 or &gt;=Length).
            </exception>
        </member>
        <member name="M:System.Span`1.ToArray">
            <summary>
            Copies the contents of this span into a new array.  This heap
            allocates, so should generally be avoided, however it is sometimes
            necessary to bridge the gap with APIs written in terms of arrays.
            </summary>
        </member>
        <member name="M:System.Span`1.DangerousGetPinnableReference">
            <summary>
            Returns a reference to the 0th element of the Span. If the Span is empty, returns a reference to the location where the 0th element
            would have been stored. Such a reference can be used for pinning but must never be dereferenced.
            </summary>
        </member>
        <member name="M:System.SpanHelpers.CopyTo``1(``0@,System.Int32,``0@,System.Int32)">
             <summary>
             Implements the copy functionality used by Span and ReadOnlySpan.
            
             NOTE: Fast span implements TryCopyTo in corelib and therefore this implementation
                   is only used by portable span. The code must live in code that only compiles
                   for portable span which means either each individual span implementation
                   of this shared code file. Other shared SpanHelper.X.cs files are compiled
                   for both portable and fast span implementations.
             </summary>
        </member>
        <member name="M:System.SpanHelpers.Add``1(System.IntPtr,System.Int32)">
             <summary>
             Computes "start + index * sizeof(T)", using the unsigned IntPtr-sized multiplication for 32 and 64 bits.
            
             Assumptions:
                 Start and index are non-negative, and already pre-validated to be within the valid range of their containing Span.
            
                 If the byte length (Span.Length * sizeof(T)) does an unsigned overflow (i.e. the buffer wraps or is too big to fit within the address space),
                 the behavior is undefined.
            
             </summary>
        </member>
        <member name="M:System.SpanHelpers.IsReferenceOrContainsReferences``1">
            <summary>
            Determine if a type is eligible for storage in unmanaged memory.
            Portable equivalent of RuntimeHelpers.IsReferenceOrContainsReferences{T}()
            </summary>
        </member>
        <member name="T:System.Numerics.BitOperations">
            <summary>
            Utility methods for intrinsic bit-twiddling operations.
            The methods use hardware intrinsics when available on the underlying platform,
            otherwise they use optimized software fallbacks.
            </summary>
        </member>
        <member name="M:System.Numerics.BitOperations.LeadingZeroCount(System.UInt32)">
            <summary>
            Count the number of leading zero bits in a mask.
            Similar in behavior to the x86 instruction LZCNT.
            </summary>
            <param name="value">The value.</param>
        </member>
        <member name="M:System.Numerics.BitOperations.LeadingZeroCount(System.UInt64)">
            <summary>
            Count the number of leading zero bits in a mask.
            Similar in behavior to the x86 instruction LZCNT.
            </summary>
            <param name="value">The value.</param>
        </member>
        <member name="M:System.Numerics.BitOperations.Log2(System.UInt32)">
            <summary>
            Returns the integer (floor) log of the specified value, base 2.
            Note that by convention, input value 0 returns 0 since log(0) is undefined.
            </summary>
            <param name="value">The value.</param>
        </member>
        <member name="M:System.Numerics.BitOperations.Log2(System.UInt64)">
            <summary>
            Returns the integer (floor) log of the specified value, base 2.
            Note that by convention, input value 0 returns 0 since log(0) is undefined.
            </summary>
            <param name="value">The value.</param>
        </member>
        <member name="M:System.Numerics.BitOperations.Log2SoftwareFallback(System.UInt32)">
            <summary>
            Returns the integer (floor) log of the specified value, base 2.
            Note that by convention, input value 0 returns 0 since Log(0) is undefined.
            Does not directly use any hardware intrinsics, nor does it incur branching.
            </summary>
            <param name="value">The value.</param>
        </member>
        <member name="M:System.Numerics.BitOperations.Log2Ceiling(System.UInt32)">
            <summary>Returns the integer (ceiling) log of the specified value, base 2.</summary>
            <param name="value">The value.</param>
        </member>
        <member name="M:System.Numerics.BitOperations.Log2Ceiling(System.UInt64)">
            <summary>Returns the integer (ceiling) log of the specified value, base 2.</summary>
            <param name="value">The value.</param>
        </member>
        <member name="M:System.Numerics.BitOperations.PopCount(System.UInt32)">
            <summary>
            Returns the population count (number of bits set) of a mask.
            Similar in behavior to the x86 instruction POPCNT.
            </summary>
            <param name="value">The value.</param>
        </member>
        <member name="M:System.Numerics.BitOperations.PopCount(System.UInt64)">
            <summary>
            Returns the population count (number of bits set) of a mask.
            Similar in behavior to the x86 instruction POPCNT.
            </summary>
            <param name="value">The value.</param>
        </member>
        <member name="M:System.Numerics.BitOperations.TrailingZeroCount(System.Int32)">
            <summary>
            Count the number of trailing zero bits in an integer value.
            Similar in behavior to the x86 instruction TZCNT.
            </summary>
            <param name="value">The value.</param>
        </member>
        <member name="M:System.Numerics.BitOperations.TrailingZeroCount(System.UInt32)">
            <summary>
            Count the number of trailing zero bits in an integer value.
            Similar in behavior to the x86 instruction TZCNT.
            </summary>
            <param name="value">The value.</param>
        </member>
        <member name="M:System.Numerics.BitOperations.TrailingZeroCount(System.Int64)">
            <summary>
            Count the number of trailing zero bits in a mask.
            Similar in behavior to the x86 instruction TZCNT.
            </summary>
            <param name="value">The value.</param>
        </member>
        <member name="M:System.Numerics.BitOperations.TrailingZeroCount(System.UInt64)">
            <summary>
            Count the number of trailing zero bits in a mask.
            Similar in behavior to the x86 instruction TZCNT.
            </summary>
            <param name="value">The value.</param>
        </member>
        <member name="M:System.Numerics.BitOperations.RotateLeft(System.UInt32,System.Int32)">
            <summary>
            Rotates the specified value left by the specified number of bits.
            Similar in behavior to the x86 instruction ROL.
            </summary>
            <param name="value">The value to rotate.</param>
            <param name="offset">The number of bits to rotate by.
            Any value outside the range [0..31] is treated as congruent mod 32.</param>
            <returns>The rotated value.</returns>
        </member>
        <member name="M:System.Numerics.BitOperations.RotateLeft(System.UInt64,System.Int32)">
            <summary>
            Rotates the specified value left by the specified number of bits.
            Similar in behavior to the x86 instruction ROL.
            </summary>
            <param name="value">The value to rotate.</param>
            <param name="offset">The number of bits to rotate by.
            Any value outside the range [0..63] is treated as congruent mod 64.</param>
            <returns>The rotated value.</returns>
        </member>
        <member name="M:System.Numerics.BitOperations.RotateRight(System.UInt32,System.Int32)">
            <summary>
            Rotates the specified value right by the specified number of bits.
            Similar in behavior to the x86 instruction ROR.
            </summary>
            <param name="value">The value to rotate.</param>
            <param name="offset">The number of bits to rotate by.
            Any value outside the range [0..31] is treated as congruent mod 32.</param>
            <returns>The rotated value.</returns>
        </member>
        <member name="M:System.Numerics.BitOperations.RotateRight(System.UInt64,System.Int32)">
            <summary>
            Rotates the specified value right by the specified number of bits.
            Similar in behavior to the x86 instruction ROR.
            </summary>
            <param name="value">The value to rotate.</param>
            <param name="offset">The number of bits to rotate by.
            Any value outside the range [0..63] is treated as congruent mod 64.</param>
            <returns>The rotated value.</returns>
        </member>
        <member name="M:System.Numerics.BitOperations.ResetLowestSetBit(System.UInt32)">
            <summary>
            Reset the lowest significant bit in the given value
            </summary>
        </member>
        <member name="M:System.Numerics.BitOperations.ResetBit(System.UInt32,System.Int32)">
            <summary>
            Reset specific bit in the given value
            </summary>
        </member>
        <member name="T:System.Numerics.BitOperationsEx">
            <summary>
            Extensions to <see cref="T:System.StringComparer"/> providing consistent access to APIs introduced after the type.
            </summary>
        </member>
        <member name="M:System.Numerics.BitOperationsEx.IsPow2(System.Int32)">
            <summary>
            Evaluate whether a given integral value is a power of 2.
            </summary>
            <param name="value">The value.</param>
        </member>
        <member name="M:System.Numerics.BitOperationsEx.IsPow2(System.UInt32)">
            <summary>
            Evaluate whether a given integral value is a power of 2.
            </summary>
            <param name="value">The value.</param>
        </member>
        <member name="M:System.Numerics.BitOperationsEx.IsPow2(System.Int64)">
            <summary>
            Evaluate whether a given integral value is a power of 2.
            </summary>
            <param name="value">The value.</param>
        </member>
        <member name="M:System.Numerics.BitOperationsEx.IsPow2(System.UInt64)">
            <summary>
            Evaluate whether a given integral value is a power of 2.
            </summary>
            <param name="value">The value.</param>
        </member>
        <member name="M:System.Numerics.BitOperationsEx.IsPow2(System.IntPtr)">
            <summary>
            Evaluate whether a given integral value is a power of 2.
            </summary>
            <param name="value">The value.</param>
        </member>
        <member name="M:System.Numerics.BitOperationsEx.IsPow2(System.UIntPtr)">
            <summary>
            Evaluate whether a given integral value is a power of 2.
            </summary>
            <param name="value">The value.</param>
        </member>
        <member name="M:System.Numerics.BitOperationsEx.RoundUpToPowerOf2(System.UInt32)">
            <summary>Round the given integral value up to a power of 2.</summary>
            <param name="value">The value.</param>
            <returns>
            The smallest power of 2 which is greater than or equal to <paramref name="value"/>.
            If <paramref name="value"/> is 0 or the result overflows, returns 0.
            </returns>
        </member>
        <member name="M:System.Numerics.BitOperationsEx.RoundUpToPowerOf2(System.UInt64)">
            <summary>
            Round the given integral value up to a power of 2.
            </summary>
            <param name="value">The value.</param>
            <returns>
            The smallest power of 2 which is greater than or equal to <paramref name="value"/>.
            If <paramref name="value"/> is 0 or the result overflows, returns 0.
            </returns>
        </member>
        <member name="M:System.Numerics.BitOperationsEx.RoundUpToPowerOf2(System.UIntPtr)">
            <summary>
            Round the given integral value up to a power of 2.
            </summary>
            <param name="value">The value.</param>
            <returns>
            The smallest power of 2 which is greater than or equal to <paramref name="value"/>.
            If <paramref name="value"/> is 0 or the result overflows, returns 0.
            </returns>
        </member>
        <member name="M:System.Numerics.BitOperationsEx.LeadingZeroCount(System.UInt32)">
            <summary>
            Count the number of leading zero bits in a mask.
            Similar in behavior to the x86 instruction LZCNT.
            </summary>
            <param name="value">The value.</param>
        </member>
        <member name="M:System.Numerics.BitOperationsEx.LeadingZeroCount(System.UInt64)">
            <summary>
            Count the number of leading zero bits in a mask.
            Similar in behavior to the x86 instruction LZCNT.
            </summary>
            <param name="value">The value.</param>
        </member>
        <member name="M:System.Numerics.BitOperationsEx.LeadingZeroCount(System.UIntPtr)">
            <summary>
            Count the number of leading zero bits in a mask.
            Similar in behavior to the x86 instruction LZCNT.
            </summary>
            <param name="value">The value.</param>
        </member>
        <member name="M:System.Numerics.BitOperationsEx.Log2(System.UInt32)">
            <summary>
            Returns the integer (floor) log of the specified value, base 2.
            Note that by convention, input value 0 returns 0 since log(0) is undefined.
            </summary>
            <param name="value">The value.</param>
        </member>
        <member name="M:System.Numerics.BitOperationsEx.Log2(System.UInt64)">
            <summary>
            Returns the integer (floor) log of the specified value, base 2.
            Note that by convention, input value 0 returns 0 since log(0) is undefined.
            </summary>
            <param name="value">The value.</param>
        </member>
        <member name="M:System.Numerics.BitOperationsEx.Log2(System.UIntPtr)">
            <summary>
            Returns the integer (floor) log of the specified value, base 2.
            Note that by convention, input value 0 returns 0 since log(0) is undefined.
            </summary>
            <param name="value">The value.</param>
        </member>
        <member name="M:System.Numerics.BitOperationsEx.PopCount(System.UInt32)">
            <summary>
            Returns the population count (number of bits set) of a mask.
            Similar in behavior to the x86 instruction POPCNT.
            </summary>
            <param name="value">The value.</param>
        </member>
        <member name="M:System.Numerics.BitOperationsEx.PopCount(System.UInt64)">
            <summary>
            Returns the population count (number of bits set) of a mask.
            Similar in behavior to the x86 instruction POPCNT.
            </summary>
            <param name="value">The value.</param>
        </member>
        <member name="M:System.Numerics.BitOperationsEx.PopCount(System.UIntPtr)">
            <summary>
            Returns the population count (number of bits set) of a mask.
            Similar in behavior to the x86 instruction POPCNT.
            </summary>
            <param name="value">The value.</param>
        </member>
        <member name="M:System.Numerics.BitOperationsEx.TrailingZeroCount(System.Int32)">
            <summary>
            Count the number of trailing zero bits in an integer value.
            Similar in behavior to the x86 instruction TZCNT.
            </summary>
            <param name="value">The value.</param>
        </member>
        <member name="M:System.Numerics.BitOperationsEx.TrailingZeroCount(System.UInt32)">
            <summary>
            Count the number of trailing zero bits in an integer value.
            Similar in behavior to the x86 instruction TZCNT.
            </summary>
            <param name="value">The value.</param>
        </member>
        <member name="M:System.Numerics.BitOperationsEx.TrailingZeroCount(System.Int64)">
            <summary>
            Count the number of trailing zero bits in a mask.
            Similar in behavior to the x86 instruction TZCNT.
            </summary>
            <param name="value">The value.</param>
        </member>
        <member name="M:System.Numerics.BitOperationsEx.TrailingZeroCount(System.UInt64)">
            <summary>
            Count the number of trailing zero bits in a mask.
            Similar in behavior to the x86 instruction TZCNT.
            </summary>
            <param name="value">The value.</param>
        </member>
        <member name="M:System.Numerics.BitOperationsEx.TrailingZeroCount(System.IntPtr)">
            <summary>
            Count the number of trailing zero bits in a mask.
            Similar in behavior to the x86 instruction TZCNT.
            </summary>
            <param name="value">The value.</param>
        </member>
        <member name="M:System.Numerics.BitOperationsEx.TrailingZeroCount(System.UIntPtr)">
            <summary>
            Count the number of trailing zero bits in a mask.
            Similar in behavior to the x86 instruction TZCNT.
            </summary>
            <param name="value">The value.</param>
        </member>
        <member name="M:System.Numerics.BitOperationsEx.RotateLeft(System.UInt32,System.Int32)">
            <summary>
            Rotates the specified value left by the specified number of bits.
            Similar in behavior to the x86 instruction ROL.
            </summary>
            <param name="value">The value to rotate.</param>
            <param name="offset">The number of bits to rotate by.
            Any value outside the range [0..31] is treated as congruent mod 32.</param>
            <returns>The rotated value.</returns>
        </member>
        <member name="M:System.Numerics.BitOperationsEx.RotateLeft(System.UInt64,System.Int32)">
            <summary>
            Rotates the specified value left by the specified number of bits.
            Similar in behavior to the x86 instruction ROL.
            </summary>
            <param name="value">The value to rotate.</param>
            <param name="offset">The number of bits to rotate by.
            Any value outside the range [0..63] is treated as congruent mod 64.</param>
            <returns>The rotated value.</returns>
        </member>
        <member name="M:System.Numerics.BitOperationsEx.RotateLeft(System.UIntPtr,System.Int32)">
            <summary>
            Rotates the specified value left by the specified number of bits.
            Similar in behavior to the x86 instruction ROL.
            </summary>
            <param name="value">The value to rotate.</param>
            <param name="offset">The number of bits to rotate by.
            Any value outside the range [0..31] is treated as congruent mod 32 on a 32-bit process,
            and any value outside the range [0..63] is treated as congruent mod 64 on a 64-bit process.</param>
            <returns>The rotated value.</returns>
        </member>
        <member name="M:System.Numerics.BitOperationsEx.RotateRight(System.UInt32,System.Int32)">
            <summary>
            Rotates the specified value right by the specified number of bits.
            Similar in behavior to the x86 instruction ROR.
            </summary>
            <param name="value">The value to rotate.</param>
            <param name="offset">The number of bits to rotate by.
            Any value outside the range [0..31] is treated as congruent mod 32.</param>
            <returns>The rotated value.</returns>
        </member>
        <member name="M:System.Numerics.BitOperationsEx.RotateRight(System.UInt64,System.Int32)">
            <summary>
            Rotates the specified value right by the specified number of bits.
            Similar in behavior to the x86 instruction ROR.
            </summary>
            <param name="value">The value to rotate.</param>
            <param name="offset">The number of bits to rotate by.
            Any value outside the range [0..63] is treated as congruent mod 64.</param>
            <returns>The rotated value.</returns>
        </member>
        <member name="M:System.Numerics.BitOperationsEx.RotateRight(System.UIntPtr,System.Int32)">
            <summary>
            Rotates the specified value right by the specified number of bits.
            Similar in behavior to the x86 instruction ROR.
            </summary>
            <param name="value">The value to rotate.</param>
            <param name="offset">The number of bits to rotate by.
            Any value outside the range [0..31] is treated as congruent mod 32 on a 32-bit process,
            and any value outside the range [0..63] is treated as congruent mod 64 on a 64-bit process.</param>
            <returns>The rotated value.</returns>
        </member>
        <member name="T:System.StringComparerEx">
            <summary>
            Extensions to <see cref="T:System.StringComparer"/> providing consistent access to APIs introduced after the type.
            </summary>
        </member>
        <member name="T:System.Threading.MonitorEx">
            <summary>
            Extensions to <see cref="T:System.Threading.Monitor"/> providing consistent access to APIs introduced after the type.
            </summary>
        </member>
    </members>
</doc>
